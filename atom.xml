<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marsen&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/be6152866ede00bca9d8f92aa352c938</icon>
  <subtitle>waiting to load</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.marsen.me/"/>
  <updated>2020-09-14T10:40:05.290Z</updated>
  <id>https://blog.marsen.me/</id>
  
  <author>
    <name>Marsen L.</name>
    <email>thisismysoul@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[生活筆記] TUTORING APP 多特英 第四屆體驗大使</title>
    <link href="https://blog.marsen.me/2020/09/09/2020/before_try_tutoring_app/"/>
    <id>https://blog.marsen.me/2020/09/09/2020/before_try_tutoring_app/</id>
    <published>2020-09-09T06:53:03.000Z</published>
    <updated>2020-09-14T10:40:05.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>學英文一直以來都是我的硬傷，<br>而且不論是補習、聽歌、看美劇各種方法我都試過，<br>也不能說沒有效，就是無法持續且無法應用在生活上，<br>所以有什機會能夠讓自已更進步我都會想試試看。</p><p>這篇文章可能有點微工商，<br>總之前幾天我滑到這個廣告，  </p><p><a href="https://www.facebook.com/TutoringApp/posts/645426629424215?__cft__[0]=AZWZ8RmP2GoiGK3qd63VguoGdXajn0Xsaj8ZPBzO7H_XUKKw2gpBqpPWDip9Ei_XQA2Ac4AOOmvnp6_XzdYSKZDA_PmSFiQdUzq2UKUbZylDsFQhrCya_gsvDFOWG5dyRZoemH7m0pzswr08rfBYX2dTbfLiWBSpjR4pX-TIPCUj7g&__tn__=%2CO%2CP-R" target="_blank" rel="noopener"><img src="https://i.imgur.com/KaAdrTh.png" alt="看到這個廣告"></a></p><p>我只是一個小小工程師，<br>不是網紅應該沒什麼流量(應該是我在蹭 TUTORING APP 的流量 XD)，<br>竟然也能錄取，真的覺得很開心呢，<br>這也是這篇文章誕生的原因啦。</p><p>同時，這個兩禮拜我剛好特別忙(應該會忙到 10 月初)，<br>工作之外還有表演的排練、教學課程的準備以及一場讀書會的發表。<br>我本來應該拒絕，但是我還是想挑戰看看，<br>首先是 9 堂課其實只有 180 分鐘(9x20)而已，應該不是難到無法克服程度。<br>再來是 TUTORING APP 其實很方便，我想試試是否能隨時找到安靜的角落，<br>就能夠完成一次英文對話(比起上課我更想閒聊啦)。<br>最後是我原本就有打算要寫一篇 Blog 來記錄這件事，<br>那就順水推舟一下，讓這篇文章誕生啦。</p><h2 id="參加-TUTORING-兩週學習挑戰的動機-原因"><a href="#參加-TUTORING-兩週學習挑戰的動機-原因" class="headerlink" title="參加 TUTORING 兩週學習挑戰的動機/原因"></a>參加 TUTORING 兩週學習挑戰的動機/原因</h2><p>在今年初，肺炎還沒有在世界上造成大流行，可以出國趴趴造的一月，<br>就曾經試用過這個 APP，當時我在上面臨時找了一個菲律賓老師，<br>選擇了一個簡單的課程，體驗的時間很短，應該不到一小時，<br>但是給我留下很好的印象，時間超彈性，找到老師到上課大概花不到 1 分鐘。<br>這對我來說很方便。</p><p>APP 的操作也很直覺順手，當時其實有想要再體驗幾次，<br>可惜那時候工作比較忙錄的情況下，<br>一不小心就過期了(還是次數用完 ? 我忘了)  </p><p>其實我比較希望由母語教師來教，但是上了那堂課後的確讓我改觀，<br>TUTORING APP 其實也是有母語教師的，但是好的老師就是好的老師，是不分國籍與母語的。<br>所以可以看一下老師的簡介與評分，也可以聽聽發音，<br>可能我聽多了印度英文(線上程式課)，我反而覺得英國腔有點不習慣XD，<br>但那次上課的菲律賓老師，咬字與發音真的都很好，完全不比母語老師差，人也很有耐心。  </p><p>網路上有很多的英文教材，台灣也有很多英語學習的管道與廣告，<br>為什麼 TUTORING APP 會吸引我呢 ?<br>不是因為他的圖示很可愛，而<strong>是不用留電話</strong>這一點，<br>蠻多英文教學的課程廣告都會要求留電話，<br>為了你留電話，會打折會送測試送體驗，但是<strong>千萬不要留電話</strong>。<br>除非你想要有接不完的銷售電話…<br>一直約課程、約實體見面，甚至催你買課…。<br>而我追求的是時間彈性，空間彈性的上課方式，<br>明明有類似 TUTORING APP 的服務(真人線上英文學習一對一家教)，<br>我就不懂為什麼要留言電話，電訪行銷不是 1980 年代的東西了嗎 ?<br>另外一方面，我會參加一些語言交換的聚會，<br>不過目前程度還是太差，所以聊得很乾(其實我用母語聊天一樣乾…)，<br>有一個教材讓我跟著學習反而是比較輕鬆的方式練習英文口說，當然我也是會繼續參加線下活動。<br>多認識一下外國的朋友:)。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://bit.ly/3dJk4Sr" target="_blank" rel="noopener">TUTORING APP 下載</a></li><li><a href="https://tutoring.pixnet.net/blog/post/3797354" target="_blank" rel="noopener">價格介紹文章</a></li><li><a href="https://tutoring.pixnet.net/blog/post/12459416" target="_blank" rel="noopener">TUTORING客服</a></li><li><a href="https://tutoring.pixnet.net/blog/post/7117913-app%e4%bd%bf%e7%94%a8%e4%bb%8b%e7%b4%b9%ef%bd%9c%e5%a6%82%e4%bd%95%e7%8d%b2%e5%be%97%e5%85%8d%e8%b2%bb%e6%b0%b4%e5%b9%b3%e6%b8%ac%e8%a9%a6%e5%88%b8%ef%bc%9f%ef%bd%9ctut" target="_blank" rel="noopener">獲得免費水平測試</a></li><li><a href="https://tutoring.pixnet.net/blog/category/270020" target="_blank" rel="noopener">使用FAQ</a></li><li><a href="https://tutoring.pixnet.net/blog/category/219587" target="_blank" rel="noopener">用戶反饋</a></li><li><a href="https://tutoring.pixnet.net/blog/category/214517" target="_blank" rel="noopener">外師推薦</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;學英文一直以來都是我的硬傷，&lt;br&gt;而且不論是補習、聽歌、看美劇各種方法我都試過，&lt;br&gt;也不能說沒有效，就是無法持續且無法
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[翻譯]每個 Sprint 都需要 Retrospective Meeting 嗎 ？</title>
    <link href="https://blog.marsen.me/2020/09/07/2020/does_a_scrum_team_need_a_retrospective_every_sprint/"/>
    <id>https://blog.marsen.me/2020/09/07/2020/does_a_scrum_team_need_a_retrospective_every_sprint/</id>
    <published>2020-09-07T09:43:03.000Z</published>
    <updated>2020-09-14T10:40:05.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="擷錄翻譯"><a href="#擷錄翻譯" class="headerlink" title="擷錄翻譯"></a>擷錄翻譯</h2><h3 id="常見的問題"><a href="#常見的問題" class="headerlink" title="常見的問題"></a>常見的問題</h3><ul><li>我們的團隊很棒，我們沒有需要改進的項目…</li><li>回顧會議很無聊，所以…</li><li>我們實際的工作太忙了(或回顧會議太花時間了)…</li><li>我就不喜歡回顧…  </li></ul><h3 id="你永遠不夠好到太好"><a href="#你永遠不夠好到太好" class="headerlink" title="你永遠不夠好到太好"></a>你永遠不夠好到太好</h3><blockquote><p>作者舉自已經驗 10 年的團隊，每 2 周的回顧仍有許多改善的地方。</p></blockquote><p>實際上你永遠不會好到太好，即便你已經是市場上最好的團隊。<br>在 VUCA 的世界一切都在變，就像一句老話說的「逆水行舟，不進則退」<br>看看世上最好的職業球隊，三連冠很棒，但是你試過四連冠、五連冠嗎?<br>再談談軟體的熵，為了滿足各種需求，你開始切前後端、開始用微服務<br>容器化技術、DevOps 到 SRE …<br>只會變得更細緻、更專業、更多的溝通…</p><p>所以真正的問題或許是，<strong>為什麼你覺得你不能更好了呢 ?</strong></p><h3 id="回顧會議很無聊"><a href="#回顧會議很無聊" class="headerlink" title="回顧會議很無聊"></a>回顧會議很無聊</h3><blockquote><p>作者提供了幾個方法讓回顧會議回覆活力</p><ol><li>由別的團隊的 Scrum Master 來帶領你的團隊的回顧會議</li><li>改變場地</li><li>使用不同風格進行<br>推薦書單 <a href="https://www.amazon.com/Improving-Agile-Retrospectives-Efficient-Addison-Wesley/dp/0134678346" target="_blank" rel="noopener">Improving Agile Retrospectives</a></li></ol></blockquote><p>尋求社群的建議，我個人再推薦一個網站 <a href="https://www.funretrospectives.com/" target="_blank" rel="noopener">FunRetrospectives</a>…<br>回顧會議很無聊對 Scrum Master 應該是個警鐘，<br>但是醫生也會生病，請勇敢的尋求協助，而不是僵化的照本宣科，  </p><p><em>No one said a retrospective should be as exciting as the latest Hollywood blockbuster.But there are things you can to do to liven them up.</em></p><h3 id="Too-Busy-To-Improve"><a href="#Too-Busy-To-Improve" class="headerlink" title="Too Busy To Improve"></a>Too Busy To Improve</h3><p><img src="https://i.imgur.com/VkHvIDP.png" alt="too busy to improve"></p><blockquote><p>作者僅說明這樣是一個短視的團隊，<br>同時引用《高效率人士的七個習慣》書中的故事<br>短視近利的樵夫永遠不會打磨他的斧頭。</p></blockquote><p>請注意「短視」的文化根歸何處 ?<br>這是一個複雜的問題，需要細心的觀察。<br>是團隊嗎 ? 或是 PO ? 也有可能是老闆或是客戶。<br>需要用系統思考的方式找到癥結點。<br>然後 — Change Your Company !</p><h3 id="我就是不喜歡回顧"><a href="#我就是不喜歡回顧" class="headerlink" title="我就是不喜歡回顧"></a>我就是不喜歡回顧</h3><blockquote><p>這個可能回顧會議變得無聊的變形<br>但作者將兩者分別出來的原因是，有的人就只是單純不喜歡而已<br>這些人只想作他們想作的部份…</p></blockquote><p>作者例子基本上是團隊的害蟲了，<br>實務上我認為更多是人的價值觀不同，<br>在一般的開發人員或是 Team Member 身上或許還好解決，<br>透過溝通，排除他的困難。<br>個人經驗上比較麻煩的反而是中階主管，<br>比如說 : Team Leader 身兼 Team Member，<br>但是每次都翹掉回顧會議，說「我有其它會議、我很忙、我很特別…」  </p><p>我的想法是將他的角色提昇到 StackHolder，如果他的權限會影響開發，<br>鼓勵他下放，讓 Team Members 具備獨力開發的能力。<br>讓他去作特別的事，反之如果他回頭想參與開發，<br>那應該與其它 Team Members 一樣全程參與會議。</p><p>黑暗兵法:在回顧會議取回他會影響開發的權限。喔，你當然可以選擇一場他不在的場次 :)</p><p>最後作者仍然補上可以減少回顧的可能性，</p><blockquote><p>當你的團隊真得很棒，<br>或是為了讓回顧不無聊而付出巨大的努力，<br>或是你的團隊其實不太忙，甚至不太需要什麼改善計劃(可能要改善需求端)<br>能理解工作與喜歡作的項目的價值<br><strong>團隊在一個極短的 sprint之中</strong><br>可以減少團隊的回顧會議</p><p>If your team:</p><p>Is really good.<br>Has made significant efforts to make sure retrospectives aren’t boring.<br>Is not too busy to invest in improvements that don’t pay them back  immediately.<br>And understands the value of doing other than just the most pleasant work.</p><p>… and if they work in short sprints, I’ll say it’s OK for the team do retrospectives less frequently.</p></blockquote><p>但是並不建議，僅僅為了這個理由改變 Sprint 的長度，<br>而 Scrum Master 應該悍衛每個 Sprint 應執行的回顧會議，<br>但也可以適當調整為每兩個 Sprint 一次。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.mountaingoatsoftware.com/blog/does-a-scrum-team-need-a-retrospective-every-sprint" target="_blank" rel="noopener">Does a Scrum Team Need aRetrospective Every Sprint?</a></li><li><a href="https://www.funretrospectives.com/" target="_blank" rel="noopener">FunRetrospectives</a></li><li><a href="https://www.betteruserstories.com/courses/better-user-stories/videos?video_id=1" target="_blank" rel="noopener">https://www.betteruserstories.com/courses/better-user-stories/videos?video_id=1</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;擷錄翻譯&quot;&gt;&lt;a href=&quot;#擷錄翻譯&quot; class=&quot;headerlink&quot; title=&quot;擷錄翻譯&quot;&gt;&lt;/a&gt;擷錄翻譯&lt;/h2&gt;&lt;h3 id=&quot;常見的問題&quot;&gt;&lt;a href=&quot;#常見的問題&quot; class=&quot;headerlink&quot; title=&quot;常見的問題&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[N社筆記] 沒有後端不行嗎？</title>
    <link href="https://blog.marsen.me/2020/08/29/2020/coupon_on_f2e/"/>
    <id>https://blog.marsen.me/2020/08/29/2020/coupon_on_f2e/</id>
    <published>2020-08-29T05:03:47.000Z</published>
    <updated>2020-09-02T17:02:57.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>我在今年３月已經離開 N 社了，<br>不過這幾天在社群與朋友蠻多人在討論一個來自<a href="https://kaobei.engineer/cards/show/5087?fbclid=IwAR0QxJCSvn_ULFo_gwqQmORL5y8UX22LBdf5neAXikALWfjo7DGA91Ohlw0" target="_blank" rel="noopener">靠北工程師</a>的話題，<br>我看了一下後，有些自已的想法，稍微記錄一下。</p><p>另外延伸討論另一個最近炎上的話題，<br>前端不用寫程式 !? 出道(?)為<del>全端</del>網站工程師的我，談談我的看法。</p><h2 id="事件-靠北工程師-把序號寫在JS裡面"><a href="#事件-靠北工程師-把序號寫在JS裡面" class="headerlink" title="事件 靠北工程師-把序號寫在JS裡面"></a>事件 靠北工程師-把序號寫在JS裡面</h2><p><a href="https://www.facebook.com/init.kobeengineer/photos/a.1416496745064002/3246423438737981" target="_blank" rel="noopener">靠北文章聯結</a><br>簡單的說，這是一個抽獎的功能，可以抽最高 550 元的折價券，<br>然後所有的實現都在前端，facebook 留言的回覆蠻有趣，<br>已經有人寫<a href="https://medium.com/@kurosean/%E9%96%8B%E7%AE%B191app%E7%98%8B%E5%9E%8B%E8%BD%89%E8%BD%89%E6%A8%82-7e74d402e708" target="_blank" rel="noopener">相關文章</a>，有興趣可以看看始末。</p><p>回覆的留言大多分為幾種，</p><ol><li>(只?)有註解很棒</li><li>序號、次數等不應該寫在前端</li><li>資料筆數很多，應該怎麼處理等等…<br>另外有一些來自 N 社的員工(?)留言這是行銷部門替 T 廠找的外包，<br>所以不代表 N 社的工程單位會寫出這樣的代碼。  </li></ol><blockquote><p>20200902 補充:<br>可靠消息指出「那包code 不只是外包而已，是給一包範本<br>叫廠商自己改完，然後放到某位置去做活動」</p><p>以上需求為前提，陣列的處理也可以理解了，<br>整份代碼也是相同適合廠商修改，雖然不知道改得人會是工讀生還是總經理。<br>總之這樣的需求下，這份代碼我覺得是合格的。<br>反思 : If I Had Only One Hour To Save The World I Would Spend 55 Minutes Defining The Problem And 5 Minutes Finding The Solution.</p></blockquote><h3 id="反思-靠北工程師"><a href="#反思-靠北工程師" class="headerlink" title="反思 靠北工程師"></a>反思 靠北工程師</h3><p>這邊說說我的看法，<br>現在的我已經離開前端開發一陣子了，<br>但是我覺得這份代碼(只論抽獎 js 的部份)是簡單好懂的，<br>反而釣出有人作免費的 Code Review ，很多建議也算是不錯。<br>但這是公司文化層面上的一個問題，<br>有沒有遇過「前輩」堅持某種(好壞不論)寫法呢 ?  </p><p>撇除 Style 與 Code smell，這段代碼我覺得已經用最簡單的方式達到目的了。<br>抽獎與增券，稍微操作一樣可以理解了，抽獎完後，你可以拿到一個折價券號。<br>然後…這些資訊都在 js 代碼之中。<br>稍微有一點概念的話，你可以直接拿到 550 元的折價券的序號，  </p><p><strong>然後呢 ?</strong></p><p>如果你去消費的話，T 廠與 N 社行銷的目的就達成了… 。<br>而合理推測， 550 元已經在原本的計劃成本之中，而越多人買好像反而是個多贏的結局。</p><ol><li>行銷目的達成</li><li>廠商銷售成功</li><li>節少內部開發效能</li></ol><p>那另一方面，這樣的代碼出去會有什麼壞處 ?</p><ol><li>讓人覺得 N 社技術不專業 ?</li><li>轉移行銷焦點，從折扣碼到程式碼 XD</li></ol><p>有辦法改善嗎 ? 首先，我認為行銷找外包技術單位實作，是一個合理且正確的行為。<br>技術人員在各個公司仍是稀缺資源，所以流程上通常會被加上層層保護，<br>而行銷兵貴神速，用找傭兵的方式， 迅速達成客戶的需求將是必然的選擇。</p><p>再談談外包，雖然不知道收的價金多少，最主要的功能他們是實現了，<br>那有沒有辦法再好一點呢 ? 對我來說，這樣是有點傷害到 N 社開發部門的形象，<br>比如先簡單的 uglify 與 minify，<br>再進一步用一些 serverless 的作法將折扣碼隱藏起來 ?<br>或是真的起一個小小 api 服務來作這層的運算 ?<br>以我來說，頂多就多作 uglify 與 minify 就足夠了吧。<br>這也是取捨，倒是沒有什麼對錯。</p><h3 id="如何信賴專業"><a href="#如何信賴專業" class="headerlink" title="如何信賴專業"></a>如何信賴專業</h3><p>再來我想討論行銷人員<em>因為缺乏專業，所以尋求外包。但是沒有專業的他們，如何進行驗收?</em><br><del>本想舉年初館長 300 萬網站的話題，但是館長的事另有後續，故不在本篇詳述了。</del><br>舉蓋房子為例，雖然房子蓋好了，也能住人。但是風一吹就倒，或是海砂屋，你能接受嗎？<br>目前業界主要幾種解法：</p><ul><li><p>合約法：</p><blockquote><p>透過合約的法律強制力來要求甲乙方，但是在文字表述上與理解上都有太多的模糊空間，<br>最後合約會變成一本厚厚的法律全書，好像什麼都有又好像什麼都沒有。<br>專案的運作，最後仍然回歸於人;當專案有所爭議之時，怎麼解讀合約反而會取代產品本身成為焦點。</p></blockquote></li><li><p>靠關係法:</p></li></ul><blockquote><p>找信任的人作為代理人來處理，但是這樣的方式只是轉價問題，代理人缺乏專業也不少見，<br>層層溝通反而更沒效率，更常見到上線即掛點的慘案</p></blockquote><ul><li>第三方認證:</li></ul><blockquote><p>這個方法，是透過機構的認証來証明這個人具備某種能力。<br>對單一的技能是很好的門檻設定，畢業証書或是駕照都是類似的套路。<br>但是軟體開發真的只是「單一技能」嗎 ? 而你對第三方機構的信任，是不是會犯了「靠關係法」同樣的錯呢 ?<br>証照的產業，現在也有另一個困境，<br>比如說「學店」或是「雞腿換駕照」的情況不勝玫舉，這裡我不再深入討論了…<br>舉個例子來說，n 小時學會 xxx 與 1x 天學會 ooo 真的好嗎 ?  </p></blockquote><p>最後，這件事其實對一間軟體公司的專業形象是有損的，<br>我就用 <a href="https://www.facebook.com/91apptech/posts/164919178538886" target="_blank" rel="noopener">N 社的回應</a> 作為小結。<br>雖然我不知道為什麼不同步回覆到原始文章的底下，可能是公關想冷處理(之前 PTT 或其它事件也都無聲無息)<br>整個事件有很多反思的點，也有所取捨，這就是人生吧(茶)。</p><h2 id="事件二、前端不用寫程式"><a href="#事件二、前端不用寫程式" class="headerlink" title="事件二、前端不用寫程式"></a>事件二、前端不用寫程式</h2><p>另外這個事件也引起許多討論，因為我不想幫別人賣課，所以就不貼上啦。<br>可以 google 看看「 前端不用寫程式」加「15天」，應該會有意外的驚喜。<br>批判的話我就不說了，不過參考上面的事件，是不是再次說明了第三方任証機構的問題 ?<br>這種廉價的認証或是「學園」 ，他們的公信力真的可以相信嗎 ?  </p><p>這裡我想談的是，<a href="https://medium.com/marketingdatascience/%E7%B2%BE%E6%BA%96%E8%A1%8C%E9%8A%B7%E7%9A%84%E8%90%BD%E5%AF%A6-%E8%A1%8C%E9%8A%B7%E6%BC%8F%E6%96%97-304c1d1e8197" target="_blank" rel="noopener">marketing funnel(行銷漏斗)</a> 。<br>當行銷在推廣一件事情的時候，會盡可能的把餅作大，<br>但是有時候會將一些事情去脈絡化或簡化，這樣的好處是可以減少門檻讓新手玩家快速進入，<br>缺點是很有可能會誤導學員，有些觀念會被錯置。<br>而學生如果再深入一點，肯定會遇到問題。<br>對我來說，這反而是一個過濾器(filter)，進一步將專業分類，<br>學生必須學會分辨，這是成為專業的第一步。<br>有的人只是想要體驗，有的人想學以致用，有人想深入學習…。</p><p>以程式來說，先入門程式大概是什麼概念，而目前主流市場大概會用到什麼技術 ?<br>整個軟體開發的系統為何? 前端、後端、DBA、DevOps…<br>你感興趣的是哪一段 ? 你擅長的又是哪一段 ?<br>往廣度延伸或是往深度延伸，或是擴及整個產業，<br>而我的看法是當這個產業，越多人參與且越多人討論的時候，才會越健全。</p><h3 id="後續補充"><a href="#後續補充" class="headerlink" title="後續補充"></a>後續補充</h3><p><a href="https://www.youtube.com/embed/B5alI7bYwHw" target="_blank" rel="noopener">CSScoke 的 Amos</a> 的直播直接拉事主出來討論<del>謝罪</del>了，<br>有這樣的討論是很好的，也可以看出來，軟體的教學方式與系統還有很多嚐試與調整的空間，<br>看看<a href="https://www.youtube.com/watch?v=wqB8w1osofY" target="_blank" rel="noopener">網頁 15 天 Taker(道歉與回應)</a><br>寫程式這行仍在茁壯擴展之中，並且深入百業之中，但人學習的速度確漸漸的跟不上了。<br>舊有的學校系統跟不太上了，所以才產生了補教業的市場，而其中當然有良莠不齊的現象，<br>當然市場成熟後，市場機制本身就可以作一些汰除，<br>也或許這些講師也正在學習當中，我們可以繼續 <del>Diss</del> 督促，讓整個產業逐漸更加成熟。</p><p>順便評論一下兩方的公關處理方式，冷處理或直面道歉似乎效果都不錯，<br>不過我比較欣賞後者就是了。</p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;我在今年３月已經離開 N 社了，&lt;br&gt;不過這幾天在社群與朋友蠻多人在討論一個來自&lt;a href=&quot;https://kaob
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[閱讀筆記] 大話設計模式 --- 橋接模式(Bridge Pattern)</title>
    <link href="https://blog.marsen.me/2020/08/12/2020/book/talk_DP_bridge_pattern/"/>
    <id>https://blog.marsen.me/2020/08/12/2020/book/talk_DP_bridge_pattern/</id>
    <published>2020-08-12T00:22:18.000Z</published>
    <updated>2020-09-01T12:49:24.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>因緣繼會下參加了一個線上讀書會，<br>讀的是一本老書，<a href="https://www.tenlong.com.tw/products/9789866761799" target="_blank" rel="noopener">「大話設計模式」</a>，<br>簡體書應該是 2007 年出版，但是國內有繁體書，<br>我是在 2010 年左右入手這本書的，號稱簡單易懂，<br>當時翻了幾遍，但是對 Design Pattern 與 OOP 並沒有很深刻的認知。</p><p>如果對 OOP 沒有什概念的人，這本書的附錄也有簡單的介紹。<br>算是適合當作入門的書。</p><p>在實務上，卻很少看到同事在用 Design Pattern 在解決問題，<br>更多是前人怎麼作，我就怎麼作。<br>一直到我學習了 TDD 與重構，<br>我才漸漸了解 Design Pattern 是怎麼一回事，<br>書中小菜有幸遇到大鳥而我沒有，只能更多努力了。  </p><h2 id="本書小得"><a href="#本書小得" class="headerlink" title="本書小得"></a>本書小得</h2><p>這篇 blog 主要是寫書中的第 22 章–橋接模式，<br>但是我想提一下心得，也許之後會寫別的章節，也許不會，<br>但心得就先收錄在這裡了。  </p><p>首先是這本書面向的讀者應該是小菜，<br>同時是書中的主角，對物件導向與設計模式不熟悉的人，<br>所以書中用了很多現實生活中的例子來舉例，<br>當然我們可以將現實投影到程式當中，但我實際上的感受還是有差異的。<br>比起生活實例，我現在可能更希望是代碼實例吧。</p><p>第二點，書中的背景是 2007 年，所以時空背景已經不太相同了，<br>以本章(22章，橋接模式)為例，書中提到的手機遊戲跨平台問題，<br>在 2020 年已經不存在了，現在的智慧型手機與書中的「掌上電腦」功能描述差不多了。  </p><p>第三點，網路上有簡體版的書在流通，但是用語與正體中文有所差異。  </p><p>想讀這本書的人參考一下上述幾點，<br>或許結合一些其它的書籍或是網路資源，<br>對你來說可以對設計模式有更好的理解。  </p><h2 id="橋接模式"><a href="#橋接模式" class="headerlink" title="橋接模式"></a>橋接模式</h2><p>我猜想命名的原因是來自完成後的類別圖看起來的樣子，<br>在本書中舉了手機品牌(Brand)與手機軟體(Soft)的關係作為例子，<br>你可以以 <code>Brand</code> 作為分類，也可以用 <code>Soft</code> 作為分類，<br>但最後都會長出三層繼承的類別圖，<br>然後其中都會包含奇怪的職責; <code>Soft</code> 包含 <code>Brand</code> 的資訊(或是 <code>Brand</code> 包含 <code>Soft</code> 的資訊)。</p><p>而真正的問題是，難以擴充，每當我們需要一個新的 <code>Soft</code> 或是 <code>Brand</code>，<br>我就需要為所有的 <code>Brand</code> 或 <code>Soft</code> 新增一整組的類別。<br>而這問題背後的原因就是過度繼承。</p><p>書中的例子，有一處我覺得不佳的地方，<br>在使用橋接模式前，主邏輯如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"Run N Brand Game"</span>);</span><br></pre></td></tr></table></figure><p>使用橋接模式後的代碼如下，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"Run Game"</span>);</span><br></pre></td></tr></table></figure><p>作者可能想強調其橋接的觀念，而不討論橋接的兩端實際有資訊互通的需求，<br>但是我認為這是不正確的，我們不應該套用了某種 Design Pattern 而改變其原始行為。  </p><p>接下來我會以下面這張圖，Demo 一下怎麼重構到橋接模式  </p><p><img src="/images/2020/8/talk_DP_bridge_pattern_01.jpg" alt="手機品牌"></p><p>首先，先寫測試，由於我視作這個結構是遺留代碼的產物，<br>所以我不認為他會有完整的單元測試，當然如果有的話就要考慮這些測試是否仍然適用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handsetNokiaAddressBook = <span class="keyword">new</span> HandsetNokiaAddressBook();</span><br><span class="line">handsetNokiaAddressBook.Run();</span><br><span class="line"><span class="keyword">var</span> handsetNokiaGame = <span class="keyword">new</span> HandsetNokiaGame();</span><br><span class="line">handsetNokiaGame.Run();</span><br><span class="line"><span class="keyword">var</span> handsetMotorolaAddressBook = <span class="keyword">new</span> HandsetMotorolaAddressBook();</span><br><span class="line">  handsetMotorolaAddressBook.Run();</span><br><span class="line"><span class="keyword">var</span> handsetMotorolaGame = <span class="keyword">new</span> HandsetMotorolaGame();</span><br><span class="line">handsetMotorolaGame.Run();</span><br></pre></td></tr></table></figure><p>我寫了一些 End To End 測試列舉出所有的情境。</p><blockquote><p>延申問題</p><ol><li>目前只是 2 x 2，所以要寫 E2E 測試似乎不難，如果是 3 x 3 或更多呢 ? 你會怎麼作 ?</li><li>這裡隱含著一件事，當你看到你的繼承鏈與商業邏輯的交互，<br>已經開始出現 2 x 2 的現象時，是一個明示你應該重構它了。</li></ol></blockquote><p>下一步，我可以很明顯的發現中間層的類別，其實一點意義也沒有</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>所以我們要將繼承鏈中最葉端(leaf node)的類別繼承關係移除，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandsetNBrandGame</span> : <span class="title">HandsetNBrand</span></span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandsetNBrandGame</span></span><br></pre></td></tr></table></figure><p>當然我不認為實務上有這麼簡單能移除一個繼承關係，<br>所以要達到這一步之前，我們也許要先創造無意義的中間層。<br>因為這步是對葉端類別的處理，所以我喜歡稱它為「修剪枝葉節點」。</p><p>下一步，當我把所有葉端的類別剪除後，我會先作分類，<br>實務上我會更傾向在腦海中作好分類再剪除，然後一個分類一個分類重構。<br>比如說 Game 類別:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Game</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> brand</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Run <span class="subst">&#123;brand&#125;</span> Game"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到我已經將 brand 抽出來作為方法變數，<br>作為過渡時期多載(overloading)或許是個手段<br>此外，可以看到我透過參數傳遞來解除相依，<br>這個手段甚至可以套用在 delegate 或是複雜型別。</p></blockquote><p>同樣的步驟再作一次，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddressBook</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> brand</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Run <span class="subst">&#123;brand&#125;</span> Address Book"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們可以明顯發現重複的項目可以抽出介面，<br>實務不需要特別介意是 <code>interface</code> 或 <code>abstract class</code>，<br>依最小改動為原則，選擇適當的手段進行即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> brand</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddressBook</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> brand</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Run <span class="subst">&#123;brand&#125;</span> Address Book"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Game</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> brand</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Run <span class="subst">&#123;brand&#125;</span> Game"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這時候我們必須將 <code>brand</code> 傳入，  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandsetNBrand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> HandsetSoft Soft;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">string</span> Brand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandsetNBrand</span>(<span class="params">HandsetSoft soft</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Soft = soft;</span><br><span class="line">        Brand = <span class="string">"NBrand"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Soft.Run(Brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Client 端就可以組合起來使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> game = <span class="keyword">new</span> HandsetNokia(<span class="keyword">new</span> HandsetGame());</span><br><span class="line">game.Run();</span><br></pre></td></tr></table></figure><p>同樣的手法作在 <code>HandsetMBrand</code> 之中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandsetMBrand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> HandsetSoft Soft;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">string</span> Brand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandsetMBrand</span>(<span class="params">HandsetSoft soft</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Soft = soft;</span><br><span class="line">        Brand = <span class="string">"MBrand"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Soft.Run(Brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這時候可以發現重複，重構後如下。<br>除了各自的品牌資訊，大多可以共用的方法與欄位，<br>我們就抽到父類別。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandsetBrand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Application _app;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">string</span> Brand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HandsetBrand</span>(<span class="params">Application app</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _app = app;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._app.Run(Brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">HandsetNBrand</span> : <span class="title">HandsetBrand</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HandsetNBrand</span>(<span class="params">Application app</span>):<span class="title">base</span>(<span class="params">app</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      Brand = <span class="string">"NBrand"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">HandsetMBrand</span> : <span class="title">HandsetBrand</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HandsetMBrand</span>(<span class="params">Application app</span>):<span class="title">base</span>(<span class="params">app</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      Brand = <span class="string">"MBrand"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/8/talk_DP_bridge_pattern_02.jpg" alt="完成"></p><h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><ol><li>修剪枝葉，</li><li>製造重複，重構並產出 <code>Implementor</code></li><li>如果橋接的兩端有需要傳遞的資訊，考慮使用方法參數</li><li><code>Abstraction</code> 抽象呼叫 <code>Implementor</code> 來建立橋接<br><img src="/images/2020/8/talk_DP_bridge_pattern_03.jpg" alt="Bridge"></li></ol><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://refactoring.guru/design-patterns/bridge" target="_blank" rel="noopener">https://refactoring.guru/design-patterns/bridge</a></li><li><a href="https://sourcemaking.com/design_patterns/bridge" target="_blank" rel="noopener">https://sourcemaking.com/design_patterns/bridge</a></li><li><a href="https://simpleprogrammer.com/design-patterns-simplified-the-bridge-pattern/" target="_blank" rel="noopener">https://simpleprogrammer.com/design-patterns-simplified-the-bridge-pattern/</a></li><li><a href="https://www.tenlong.com.tw/products/9789867794529" target="_blank" rel="noopener">深入淺出 Design Pattern</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;因緣繼會下參加了一個線上讀書會，&lt;br&gt;讀的是一本老書，&lt;a href=&quot;https://www.tenlong.com.t
      
    
    </summary>
    
    
    
      <category term="閱讀筆記" scheme="https://blog.marsen.me/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
      <category term="OOP" scheme="https://blog.marsen.me/tags/OOP/"/>
    
      <category term="Design Pattern" scheme="https://blog.marsen.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>[閱讀筆記] 物件導向的心得與隨筆 </title>
    <link href="https://blog.marsen.me/2020/07/27/2020/oop_experience/"/>
    <id>https://blog.marsen.me/2020/07/27/2020/oop_experience/</id>
    <published>2020-07-27T08:42:16.000Z</published>
    <updated>2020-08-09T14:41:59.306Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Object 泛指所有的物件，Instance 是明確指透過 Class 創建的 Object</p><ul><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/anonymous-types" target="_blank" rel="noopener">Anonymous Types C#</a></li><li>Java ?</li></ul></li><li><p>Class 是 Object 的藍圖/設計書 ( Class 是 Object 的抽象 )  </p><ul><li>Object 是 Class 的具像化</li><li>通常透過 new Class</li><li>一種常見的應用是 Object 裡面只有欄位，用來作為資料的載體</li><li>另一種常見的應用是 Object 包含可執行的 Function</li><li>Static 另作討論</li></ul></li><li><p>Abstract Class 是 Class 的藍圖/設計書 ( Abstract Class 是 Class 的抽象 )</p><ul><li>Class 是 Abstract Class 具像化<ul><li>通常透過繼承方式</li></ul></li><li>Abstract Class 會定義共用的欄位與方法給它的子類別<ul><li>當某一個方法，實作細節必須由子類別處理時，會宣告成抽象方法 abstract method</li><li>子類別繼承後必須實作 abstract method</li><li>Abstract 無法直接具像成 Object</li></ul></li></ul></li><li><p>Interface 是 Method 的藍圖/設計 ( Interface 是 Method 的抽象 )</p><ul><li>Method 是 Interface 的具像化<ul><li>但是 Method 必須生存在 instance 上</li><li>所以不會是 Static Object</li><li>所以 Interface 必須與 Class 共存，才能在 instance 上實現</li></ul></li></ul></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object 泛指所有的物件，Instance 是明確指透過 Class 創建的 Object&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/programming
      
    
    </summary>
    
    
    
      <category term="OOP" scheme="https://blog.marsen.me/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] Tennis KATA 與 State Pattern </title>
    <link href="https://blog.marsen.me/2020/07/21/2020/tennis_kata_to_state_pattern/"/>
    <id>https://blog.marsen.me/2020/07/21/2020/tennis_kata_to_state_pattern/</id>
    <published>2020-07-21T00:16:27.000Z</published>
    <updated>2020-09-01T12:49:24.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>Tennis Kata 是我最常練習的一個題目，<br>就我個人而言，這個題目源起 91 大的極速開發，<br>目前最快只有在 17 分左右，使用 Rider with Mac 的話可能還會再慢一些。<br>我很熟悉，所以很少作需求分析，Test Case 也大多有即定的寫法。<br>手動得很快，腦卻不怎麼動了，明明這是一個相當經典的題目，<br>不過我卻被定錨了。</p><p>今年 5 月上了「測試驅動開發與持續重構」，<br>第一天 91 大也有透過 Tennis Kata 展示了一下火力，<br>那個時候又有提到可以使用 State Pattern 來實作，<br>最近工作上又恰巧有使用到 State Pattern。<br>於是我便決定要試著用 State Pattern 來進行 Tennis Kata 。  </p><p>有兩種方法，一種是無到有的 Kata，<br>一種是將現有 Tennis Production Code，<br>透過重構轉換成 State Pattern，<br>這次我選擇從無到有。</p><h2 id="第一次失敗"><a href="#第一次失敗" class="headerlink" title="第一次失敗"></a>第一次失敗</h2><p>總歸來說，需求分析作得不夠徹底，<br>Test Case 設計不良，所以很難自然而然的讓 State 產生</p><p><img src="/images/2020/7/tennis_kata_to_state_pattern_00.jpg" alt="第一次失敗"></p><p>上圖是我第一次畫的 State ，<br>現在回過頭來想想，圖型上其實可以很明顯看出重複的壞味道。<br>但是我當下完全沒有「覺察」，明明是想要消除 if else，<br>卻在 State 裡面產生了大量的 if else。  </p><h2 id="第二次不成功"><a href="#第二次不成功" class="headerlink" title="第二次不成功"></a>第二次不成功</h2><p>總而言之是作完了，但是不是很順暢。<br><img src="/images/2020/7/tennis_kata_to_state_pattern_01.jpg" alt="第二次不成功"></p><p>如上圖，我蠻粗暴的將所有比分轉換成可能的 State，<br>一樣我沒有注意到重複，但是比較起第一次的失敗，<br>這次的狀態機是將所有可能的狀態攤平，<br>這樣作是為了符合 Tennis 的規則。</p><h3 id="Test-Cases"><a href="#Test-Cases" class="headerlink" title="Test Cases"></a>Test Cases</h3><ul><li>LoveAll<ul><li>產生 Context 類別與 Score 方法</li><li>產生 LoveAll State</li><li>產生 IState 介面，包含 Score方法，讓 LoveAllState 實作 IState 介面</li></ul></li><li>FifteenLove<ul><li>產生 ServerScore 方法</li><li>產生 FifteenLove State</li><li>產生 SetContext 方法</li><li>產生 ChangeState 方法</li><li>轉換 IState 介面成為 State 抽象類別</li></ul></li><li>LoveFifteen<ul><li>產生 ReceiverScore 方法</li><li>產生 LoveFifteen State</li></ul></li><li>LoveThirty<ul><li>產生 LoveThirty State</li></ul></li><li>LoveForty<ul><li>產生 LoveForty State</li></ul></li><li>FifteenAll<ul><li>產生 FifteenAll State<br>略…</li></ul></li><li><strong>覺察重複，重構</strong><ul><li>產生 NormalState</li><li>產生 ServerPoint  </li><li>產生 ReceiverPoint  </li><li>使用 Dictionary 消除 if else</li><li>產生 SameState</li></ul></li><li>Deuce<ul><li>產生 DeuceState<br>以下略…</li></ul></li></ul><p><img src="/images/2020/7/tennis_kata_to_state_pattern_02.jpg" alt="Final State"></p><p>最後的狀態會如上圖，當大量的 State 產生之時，心裡真的有點慌慌的，<br>這次的 TDD 仍然不算順暢成功，設計階段就可以在腦中模擬的問題，<br>我拖到了開發階段，雖然後來收斂成 <code>NormalState</code> 時頗有一回事，<br>但如果在實務上，這段不確定且發散的時間仍然是太長。</p><h2 id="第三次成功，仍然不足夠"><a href="#第三次成功，仍然不足夠" class="headerlink" title="第三次成功，仍然不足夠"></a>第三次成功，仍然不足夠</h2><p>參考第二次所作的 State Diagram。<br>可以看到缺少了 Normal to Normal 的線條。<br>第三次將它補上了。<br><img src="/images/2020/7/tennis_kata_to_state_pattern_03.jpg" alt="Final State"></p><table><thead><tr><th>States</th><th>Sample</th><th>Next States</th></tr></thead><tbody><tr><td>Same</td><td>0-0,1-1,2-2</td><td>Normal</td></tr><tr><td>Normal</td><td>0-1,0-2,1-2,1-3</td><td>Same、Normal、Deuce、Win</td></tr><tr><td>Deuce</td><td>3-3,4-4,5-5</td><td>Advantage</td></tr><tr><td>Advantage</td><td>3-4,5-6</td><td>Deuce、Win</td></tr><tr><td>Win</td><td>5-3,5-7</td><td></td></tr></tbody></table><p>參考上表製作測試案例，<br>這裡我想強調的是狀態改變的動線，<br>狀態由 <code>SameState</code> 開始。</p><p>簡單筆記一下測試與重構的幾個亮點<br>完整的 commit 可以從 <a href="https://github.com/marsen/Marsen.NetCore.Dojo/commits/Kata/TennisWithStatePattern2?before=af1303f38d61abc0dba0a965e5dfadf55bc08ccd+105" target="_blank" rel="noopener">d792b2e</a>開始看</p><h3 id="Highlight-Test-Cases"><a href="#Highlight-Test-Cases" class="headerlink" title="Highlight Test Cases"></a>Highlight Test Cases</h3><p>測試的案例的設計會依 State Diagram 的箭頭來設計，<br>也就是狀態的改變，<strong>初始狀態為 <code>SameState</code> 比分為 0 - 0</strong> ，<br>並將 Design Pattern 作為指引重構出 <code>SameState</code> 。</p><p><strong>第二個測試案例</strong>也很簡單，<br>因為 <code>SameState</code> 只會往 <code>NormalState</code> 移動，<br>所以只要使用 1 - 0 或是 0 - 1 這個案例，我就可以建立出 <code>NormalState</code> 類別。<br>並且可以觀察到兩個 State 的共通性，這個時候就會重構出 <code>IState</code> 介面。</p><p>一樣看圖開發，<br><code>NormalState</code> 是最為複雜的一個狀態，他的狀態可能為  </p><ul><li>保持原樣 : <code>NormalState</code></li><li>退回平手 : <code>SameState</code></li><li>進入決勝 : <code>DeuceState</code></li><li>直接獲勝 : <code>WinState</code></li></ul><p>而剩下的狀態都算是相當簡單，<br><code>WinState</code> 的狀態不會再改變，<br><code>DeuceState</code> 只會往 <code>AdvState</code> 狀態前進，<br><code>AdvState</code> 是相對複雜的狀態，可能變成 <code>WinState</code> 也可能降回 <code>DeuceState</code> ，<br>與 <code>NormalState</code> 並沒有直接的關聯路徑，所以在案例設計上，應該放比較後面。</p><p><strong>第三個案例</strong>，我會讓 <code>NormalState</code> 變回 <code>SameState</code>，除了可以完成一條狀態改變的路徑外，<br>好處是我不用新增類別，作到最小異動。<br>一開始我的邏輯會放在 GameContext 之中，但是不論是依循著 Design Pattern 的設計，<br>或是單純考量職責，很自然地將這裡的邏輯移至 <code>NormalState</code> 之中。<br><strong>這裡案例會選用 1-1</strong> 。</p><p>但是要將邏輯移到 <code>NormalState</code> 之中時，會面臨一個問題。<br><code>NormalState</code> 之中，為了判斷是否會回到 <code>SameState</code>，<br>需要知道 GameContext 的資訊 ( ServerPoint 與 ReceiverPoint )，<br>依循 Design Pattern 的指引，<br>將會在 <code>IState</code> 之中建立 SetContext 方法。<br>儘管 <code>SameState</code> 其實不用 ServerPoint 或 ReceiverPoint 的資訊。<br>但是因為我們相依於介面 <code>IState</code> 之上，導致 <code>NormalState</code> 或 <code>SameState</code> 都要實作 SetContext 方法。</p><p>再進一步，SetContext 在不同的 State 實作上是不會有變化的，<br>所以我會轉換 <code>IState</code> 為抽像類別 <code>State</code>。<br>而我也需要在比賽初始時呼蹈後 SetContext 並將初始狀態設為 <code>SameState</code></p><p><strong>案例 4、5、6 我選擇了 0-1 、0-2 、0-3 等案例</strong>，<br>這裡實作的是 Normal to Normal 的狀態改變(其實是沒變)，透過 Dictionary 消除 if 的手法就略過不提。<br>但是也許下次我不會急著完成 <code>NormalState</code> 而是先完成 <code>WinState</code> 與 <code>DeuceState</code> 。</p><p><strong>接下來讓 3-3 這個案例，帶我們走到 <code>DeuceState</code></strong>，<br>稍微繞了一點路作 4-4 這個案例，雖然一樣是 <code>DeuceState</code>，<br>我一開始的設計案例上並沒有考量清楚，從 3-3 走到 4-4 必須經過 <code>AdvState</code>，<br>下次應該先選擇 <strong>3-4 或 4-3 的案例</strong>，<br>再透過 <strong>4-4 的案例</strong>實作 <code>AdvState</code> 回到 <code>DeuceState</code> 的這條路徑。<br>最後再將透過<strong>案例 5-3 讓 <code>AdvState</code> 走到 <code>WinState</code></strong> 與 <strong>案例 4-1 讓 <code>NormalState</code> 走到 Win</strong> 就可以結束主要的流程了。</p><p>收官的部份就是簡單的重構，與補足一些特殊比分的案例，<br>特別要注意的是 <code>NormalState</code> 的 Score 仍然有許多的 if 讓我想重構移除，<br>目前暫時沒有想法。<br>此外，實際上 Tennis 會特別重視得分的順序，<br>比如說 <strong>100-100 Deuce 這種極端案例</strong>，交互得分的情況應忠實呈現在測試之中。<br>所以在寫測試時，就要特別注意得分的順序性。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這次還是有用到一些常用的重構套路，<br>比如說，用 Dictionary 消除 if else 的手段。<br>另一個則是 <code>Template Method Pattern</code>，<br>讓我們看看以下的 commit  </p><ul><li><a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/e8ddf89fdee94d6a82115f4449e213a4874269f8" target="_blank" rel="noopener">e8ddf8</a></li><li><a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/145d3cb408ed5b39a729c4a9b22fb6744b62c48f" target="_blank" rel="noopener">145d3c</a></li></ul><p>以 <code>ServerScore</code> 方法為例，<br>本來是在定義在 Abstract Class State 之中的抽像方法，<br>由各個 State (Normal、Same、Deuce、Adv 與 Win)實作，<br>但是我們可以明顯發現， <code>Context.ServerPoint++</code> 是重複的，<br>而 <code>ChangeState</code> 才是真正抽像的地方，<br>所以我們可以在 Abstract Class State 加入以下的方法與抽像方法，  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServerScore</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Context.ServerPoint++;</span><br><span class="line">    ChangeState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure><p>這不就恰巧是 <code>Template Method Pattern</code> 嗎 ?<br>同樣的手段可以放在 <code>ReceiverScore</code> 方法再重構一次。  </p><p>實務上 Design Pattern 本來就應該星月交輝，而非千里獨行。<br>在學習 Design Pattern 的路上，不是硬套，而是找出適用場景。  </p><p>也是我比較建議的作法，透過重構自然走向 Pattern，<br>透過限制改變來提昇品質，首先要有測試保護，再找尋套路或壞味道重構，<br>最後讓 Design Pattern 成為指引，讓代碼自動躍然而上。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://refactoring.guru/design-patterns/state" target="_blank" rel="noopener">State Pattern</a></li><li><a href="https://refactoring.guru/design-patterns/template-method" target="_blank" rel="noopener">Template Method Pattern</a></li><li><a href="https://www.rulesofsport.com/sports/tennis.html" target="_blank" rel="noopener">Tennis Rules</a></li><li><a href="http://teddy-chen-tw.blogspot.com/2014/04/solid.html" target="_blank" rel="noopener">SOLID 五則皆變</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;Tennis Kata 是我最常練習的一個題目，&lt;br&gt;就我個人而言，這個題目源起 91 大的極速開發，&lt;br&gt;目前最快只有
      
    
    </summary>
    
    
    
      <category term="Unit Testing" scheme="https://blog.marsen.me/tags/Unit-Testing/"/>
    
      <category term="TDD" scheme="https://blog.marsen.me/tags/TDD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
      <category term="OOP" scheme="https://blog.marsen.me/tags/OOP/"/>
    
      <category term="Design Pattern" scheme="https://blog.marsen.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>[A社筆記] KATA 跟本是個屁，練不出什麼鬼東西，不服來戰</title>
    <link href="https://blog.marsen.me/2020/07/20/2020/kata_in_dojo/"/>
    <id>https://blog.marsen.me/2020/07/20/2020/kata_in_dojo/</id>
    <published>2020-07-20T06:27:03.000Z</published>
    <updated>2020-08-09T14:41:59.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>前幾天有個小朋友問我說<br>「想問問 Tennis KATA 練習的重點是重構嗎<br>有沒有什麼重構的目標 ?」  </p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>這讓我想起一年前寫的文章，<a href="https://blog.marsen.me/2019/01/30/2019/coding_dojo_in_company/">[N社筆記] 在公司小規模玩 Coding Dojo</a><br>順便記錄一下後續，那個實驗大概在三月隨著參與的人員忙碌而停止了，<br>然後在後續有再重啟一次，那次是使用 Production Code 進行，<br>有多一些新的成員，但是也是隨著「忙碌」與「沒時間」而停止，<br>雖然我心裡比較想直接譙那些不出席又不出聲的人渣一些髒話，<br>不過我想這就是現實吧。這也引發我後續對 <a href="https://blog.marsen.me/2020/01/28/2020/book/better_by_atul_gawande/">TDD 產鉗的反思</a>。  </p><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="簡答版"><a href="#簡答版" class="headerlink" title="簡答版"></a>簡答版</h3><p>Kata 可以幫助你學習到。</p><ul><li>需求分析</li><li>寫測試案例</li><li>TDD 與 Unit Test</li><li>找到壞味道與重構</li><li>Design Pattern</li></ul><h3 id="詳答版"><a href="#詳答版" class="headerlink" title="詳答版"></a>詳答版</h3><p>Kata 就是一個簡單的需求，當需求來的時候<br>你必需先作需求分析，透過需求分析找到測試案例。<br>如果你想學習 TDD 你可以試著讓每個測試案例趨動你的代碼生成。<br>也就是說分析測試案例的時候，你要考慮案例的順序與帶來代碼的改變。  </p><p>試著遵守 TDD 的 紅-綠-重構 準則，<br>重構包含「測試代碼」與「產品代碼」，<br>如果是 OO 語言試著去遵循「SOLID原則」，<br>試著自已隨著 Kata 的過程流動可以看到代碼的變化。  </p><p>Design Patten 可以當作目標或指引去重構代碼。<br>不過以 Design Patten 為目標的話，<br>有兩種可能:</p><ol><li>在「需求分析」階段覺察適合的 Patten 透過設計案例來趨動</li><li>在已完成的代碼中覺察適合的 Patten 在不破壞測試的情況下重構(也有可能需要加測試案例)</li></ol><h4 id="原始回答"><a href="#原始回答" class="headerlink" title="原始回答"></a>原始回答</h4><p><img src="/images/2020/7/kata_in_dojo.jpg" alt="原始回答"></p><h2 id="新的問題"><a href="#新的問題" class="headerlink" title="新的問題"></a>新的問題</h2><p>要花多少時間才能培育一個懂「OO、TDD、Refactoring、DP」的工程師 ?<br>這個性價比符合商業利益嗎 ? 職涯規劃上值得嗎 ?<br>業界真的有需求嗎 ? 還是只要會剪下貼上就好 ?<br>真正的大公司是這樣開發的嗎 ? 業界很多公司不這樣作不也活得好好的 ?<br>目前的趨勢會更加的專業分工，這些準繩依舊適用嗎 ?</p><p><strong>我還沒有答案，但我還在路上。</strong></p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;前幾天有個小朋友問我說&lt;br&gt;「想問問 Tennis KATA 練習的重點是重構嗎&lt;br&gt;有沒有什麼重構的目標 ?」  &lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[閱讀筆記] 回饋隨筆—《SCRUM敏捷實戰手冊》</title>
    <link href="https://blog.marsen.me/2020/06/30/2020/yuubuke_talk_about_scrum/"/>
    <id>https://blog.marsen.me/2020/06/30/2020/yuubuke_talk_about_scrum/</id>
    <published>2020-06-30T09:51:03.000Z</published>
    <updated>2020-08-09T14:41:59.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>朋友在一個知識型部落客的團隊中工作，<br>作了一個有關 Scrum 的影片，<br>恰巧我最近的工作與 Scrum 的導入有比較深的關係，<br>影片我也蠻喜歡的，就稍微作個筆記當作回饋。</p><h2 id="回饋隨筆"><a href="#回饋隨筆" class="headerlink" title="回饋隨筆"></a>回饋隨筆</h2><p>第一點，讓我可以看到非業界人員初探 Scrum 的角度，<br>我第一次「知道」Scrum 已經是在 C 社的事了。<br>有點忘了第一次接觸的「初心」，台灣非軟體人說這方面的非常稀少。<br>能夠提供不同視角是很重要的。  </p><p>橄欖球列陣這部份我蠻喜歡的; 雖然直譯就知道 Scrum 原本的意思，<br>但是離「光速蒙面俠」太遠，已經有點忘了那些規則，<br>現在對比起來真的很像，為了一次的達陣，你需要多少衝刺 ?<br>戰術又該怎麼選擇 ? 球員平時的訓練與臨場反應是不是也可以映射到這個業界呢 ?  </p><p>整個影片很淺顯易懂，口齒清晰即使放到 1.5 倍速還是聽得清楚，<br>可惜的是汽車廠 5 年轉型的故事我想知道更多細節或出處，<br>不是很喜歡「一半的時間，作兩倍的工作」的結論，<br>我覺得是書商的行銷手段，不是 Scrum 的目標與強項。<br>產能的提昇不過是個結果，重點是三大支柱對團隊帶來的效應。<br>沒提到透明性、檢視性與調適性我覺得蠻可惜的，  </p><p>另外個人的工作流程我不覺得需要跑 Scrum ，<br>可以試試 GTD 或 PDCA ，而且你會發現很多類似的觀念與原則。<br>Scrum 設計上是適合小型團隊的，業界說法是 3~9 人，不含 PO 與 SM<br>多人的公司也有很多別的方法論(EX: LeSS or SAFe)，這裡我不多開戰線，敏捷無它「務實」而已。<br>方法沒有不好，只有適不適合。</p><h2 id="差異"><a href="#差異" class="headerlink" title="差異"></a>差異</h2><p>有些用字跟業界不太一樣有點可惜，硬要翻譯不如保留英文或是業界常用翻譯。<br>Scrum 跟規格固定應該沒有什麼關係，不過工程上的確這樣作會帶來一些好處。<br>Scrum 跟 Agile 本質上還是有些不同， Agile 比較像願景、原則比較抽象的層次。<br>複習一下 Agile 的宣言</p><ul><li>Individuals and interactions over processes and tools</li><li>Working software over comprehensive documentation</li><li>Customer collaboration over contract negotiation</li><li>Responding to change over following a plan</li></ul><p>Scrum 是業界較常見的框架而且與其它工作法相容性非常的高，<br>就我個人而言擷取過 XP、GTD、番茄鐘、ORID 與 ToC 等方法。<br>作為一個框架，有彈性的包容各種方法是它如此廣佈的原因之一。</p><p>最後 Scrum 無法擺脫加班、Scrum 無法擺脫加班、Scrum 無法擺脫加班<br>不要盲從，Google 是先成為 google 才有導入 Scrum，你導入 Scrum 也不會成為 Google。<br>丟書前多想 3 秒鐘，丟桌上不如丟臉上，丟書不如丟辭呈。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://william-yeh.net/post/2018/11/why-safe-over-less/" target="_blank" rel="noopener">為什麼 LeSS 這麼迷人，可是總是輸給 SAFe？</a></li><li><a href="https://www.youtube.com/watch?v=dzu9yYgmO6s" target="_blank" rel="noopener">影片無法嵌入，改分享連結</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;朋友在一個知識型部落客的團隊中工作，&lt;br&gt;作了一個有關 Scrum 的影片，&lt;br&gt;恰巧我最近的工作與 Scrum 的導入
      
    
    </summary>
    
    
    
      <category term="閱讀筆記" scheme="https://blog.marsen.me/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[A社筆記] Introduce Unit Test --- 心法篇</title>
    <link href="https://blog.marsen.me/2020/06/11/2020/unit_test_introduce_on_a_taipei_1/"/>
    <id>https://blog.marsen.me/2020/06/11/2020/unit_test_introduce_on_a_taipei_1/</id>
    <published>2020-06-11T09:03:11.000Z</published>
    <updated>2020-06-26T14:49:59.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-Unit-Test-心法篇"><a href="#Why-Unit-Test-心法篇" class="headerlink" title="Why Unit Test 心法篇"></a>Why Unit Test 心法篇</h2><p>網路上很多，自已找(兇)。</p><h3 id="我的想法-about-Unit-Test"><a href="#我的想法-about-Unit-Test" class="headerlink" title="我的想法 about Unit Test"></a>我的想法 about Unit Test</h3><h4 id="點"><a href="#點" class="headerlink" title="點"></a>點</h4><ul><li>有驗收才有品質，所以我需要測試<ul><li>黑箱</li><li>白箱</li><li>整合</li><li>單元</li></ul></li><li>UT 不過是驗收的最基本的單位。</li><li>開發人員一定會測試的，不論用何種方法<ul><li>Debuger</li><li>Console Output</li><li>Break Point</li></ul></li><li>程式人員的好品德<ul><li>Laziness</li><li>Impatience</li><li>Hubris</li></ul></li><li>程式是照你寫的跑，而不是照你想的跑</li></ul><h4 id="線"><a href="#線" class="headerlink" title="線"></a>線</h4><ul><li>既然你會測試，那麼為什麼不讓它可以[重複/一鍵]被執行</li></ul><h4 id="面"><a href="#面" class="headerlink" title="面"></a>面</h4><ul><li>只是為了重複執行，何不使用現有的測試框架與工具?</li></ul><h4 id="體"><a href="#體" class="headerlink" title="體"></a>體</h4><p>先訂驗收標準，再進行開發是正常不過的作法，<br>只不過你太聰明而在腦中測試過了。<br>但是<strong>程式是照你寫的跑，而不是照你想的跑</strong>。<br>不如先寫下驗收標準(測試左移/DoD/TDD),再進行開發。<br>錦上添花的話，就透過工具讓「執行測試」可以快速重複。<br>剩下的問題是，這些驗收標準寫到多「鉅細靡遺」?<br>有沒有什麼方式可以提昇我撰寫的速度 ?</p><p>假設我有了測試保護，那麼重構將是一件安全的事。<br>壞味道可以給我提示，而 Design Pattern 可以是改善程式的一個指引。</p><h2 id="Unit-Test"><a href="#Unit-Test" class="headerlink" title="Unit Test"></a>Unit Test</h2><h3 id="3A"><a href="#3A" class="headerlink" title="3A"></a>3A</h3><p>程式寫的是 AAA (正序)心裡想的是AAA(逆序)</p><ul><li>Arrange</li><li>Act</li><li>Asset</li></ul><h3 id="紅、綠、重構"><a href="#紅、綠、重構" class="headerlink" title="紅、綠、重構"></a>紅、綠、重構</h3><p>如果以 TDD 開發，寫完新的測試後，得到的一個「綠燈」反而是一個壞味道。</p><h2 id="第一天分享"><a href="#第一天分享" class="headerlink" title="第一天分享"></a>第一天分享</h2><p>pair programming 30 min，QA 約 20分鐘。<br>先請同事實作 1+1 的 Unit Test 看一下他對測試的理解。</p><ul><li><p>建立測試專案，可以選用 xUnit</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不選 MsTest 的理由是，我比較喜歡建構子與解構子的寫法，  </span><br><span class="line">勝過 TestInitialize&#x2F;TestCleanup 的 Attribute 的寫法</span><br></pre></td></tr></table></figure></li><li><p>引導由測試寫出方法。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logic → function → class method  </span><br><span class="line">透過寫測試讓 Production 在思考中產生</span><br><span class="line">引導的沒有很成功</span><br></pre></td></tr></table></figure></li><li><p>3A 的寫法，未來會介紹沒有 3A 的寫法(為了更好的理解)</p></li><li><p><del>方法</del>測試案例的命名</p></li><li><p>介紹 Assert.Equal 取代 Debug.Assert</p></li><li><p>簡單提到三種邏輯，回傳值、改變值、互動。</p></li><li><p>為什麼我討厭 Static</p></li></ul><h3 id="未排序-預計要講的題目"><a href="#未排序-預計要講的題目" class="headerlink" title="[未排序]預計要講的題目"></a>[未排序]預計要講的題目</h3><ul><li>範例是否為偶數 → 牛奶是否過期 → 如何透過一些手法，控制不可控的類別</li><li>怎麼對 Legacy Code 作解耦 ?</li><li>介紹 Mock Framework</li><li>怎麼寫出好理解的 Assertion ?</li><li>介紹 Assert Framework</li><li>建立 A 社的道場 Repo</li><li>more …</li></ul><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><ul><li>開發<del>完</del>後，自已會完全不自已測試就丟給 QA 或客戶嗎 ?</li><li>什麼是 Dojo ?<ul><li>日文的道場，把寫程式想像成是在練功，建立一個練功的環境。  </li></ul></li><li>什麼是 Kata ?<ul><li>日文的形，或是可以說是套路/招式，一樣透過練習招式來強化自已的能力。</li></ul></li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.facebook.com/notes/kent-beck/rip-tdd/750840194948847/" target="_blank" rel="noopener">RIP TDD</a></li><li><a href="https://wiki.c2.com/?LazinessImpatienceHubris" target="_blank" rel="noopener">Laziness Impatience Hubris</a></li><li><a href="http://otischou.tw/2019/08/02/unit-test.html" target="_blank" rel="noopener">瞭解單元測試</a></li><li><a href="https://softchris.github.io/pages/dotnet-di.html" target="_blank" rel="noopener">How YOU can Learn Dependency Injection in .NET Core and C#</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Why-Unit-Test-心法篇&quot;&gt;&lt;a href=&quot;#Why-Unit-Test-心法篇&quot; class=&quot;headerlink&quot; title=&quot;Why Unit Test 心法篇&quot;&gt;&lt;/a&gt;Why Unit Test 心法篇&lt;/h2&gt;&lt;p&gt;網路上很多，自已找(
      
    
    </summary>
    
    
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] Elasticsearch Insert Data with .Net  </title>
    <link href="https://blog.marsen.me/2020/06/03/2020/elasticsearch_with_dotnet/"/>
    <id>https://blog.marsen.me/2020/06/03/2020/elasticsearch_with_dotnet/</id>
    <published>2020-06-03T02:11:06.000Z</published>
    <updated>2020-06-26T14:49:59.012Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.marsen.me/2020/05/13/2020/dotnet_logger_with_elasticsearch_kibana/">前篇</a></p><p>上次使用 Nlog 直接與 ElasticSearch 作結合，<br>這次來看看怎麼賽入資料給 ElasticSearch 。</p><h2 id="NEST"><a href="#NEST" class="headerlink" title="NEST"></a>NEST</h2><p>一般來說，ElasticSearch 只要透過呼叫 API 就可<br>但是我將使用 C# 的 Nuget 套件 <a href="https://www.elastic.co/guide/en/elasticsearch/client/net-api/current/introduction.html" target="_blank" rel="noopener">NEST</a> 來簡化呼叫 API 的行為。</p><h2 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h2><h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package NEST</span><br></pre></td></tr></table></figure><h3 id="建立連線"><a href="#建立連線" class="headerlink" title="建立連線"></a>建立連線</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="keyword">new</span> Uri(<span class="string">"http://localhost:9200"</span>);</span><br><span class="line"><span class="keyword">var</span> settings = <span class="keyword">new</span> ConnectionSettings(node);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> ElasticClient(settings);</span><br></pre></td></tr></table></figure><h3 id="寫入資料"><a href="#寫入資料" class="headerlink" title="寫入資料"></a>寫入資料</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    name = <span class="string">"test name"</span>,</span><br><span class="line">    timestamp = DateTime.Now.ToString(<span class="string">"yyyy-MM-ddTHH:mm:ss.fffffffK"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">string</span> indexName = <span class="string">$"test-index-<span class="subst">&#123;DateTime.Now:yyyy.MM.dd&#125;</span>"</span>;</span><br><span class="line">client.Index(json, idx =&gt; idx.Index(indexName));</span><br></pre></td></tr></table></figure><h3 id="Create-Index-Pattern"><a href="#Create-Index-Pattern" class="headerlink" title="Create Index Pattern"></a>Create Index Pattern</h3><p>連線進入 Kibana (<a href="http://localhost:5601/" target="_blank" rel="noopener">http://localhost:5601/</a>),  </p><p>Setting &gt; Kibana &gt; Index patterns &gt; Create index pattern  </p><p>Step 1 of 2: Define index pattern<br>輸入 <code>test-index-*</code>  </p><p>Step 2 of 2: Configure settings<br>記得選取時間軸(x軸)為 <code>timestamp</code>，這裡會透過 automap 對應欄位，<br>故在產生測試資料時，記得先產出時間資料，<br>這個範例我使用的格式為</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateTime.Now.ToString(<span class="string">"yyyy-MM-ddTHH:mm:ss.fffffffK"</span>)</span><br></pre></td></tr></table></figure><h2 id="設計共用型別"><a href="#設計共用型別" class="headerlink" title="設計共用型別"></a>設計共用型別</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Record</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime Created &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Type &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object Record &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想法是通用類別，或許用抽像類別繼承也可以 ?<br>Created 欄位用來記錄資料產生時間，<br>Type 用來記錄 Record 的型別，<br>Record 用來記錄實際的資料。</p><p>預計未來可能會需要取出 Json 資料再轉成物件操作。</p><p>大概就醬。</p><h3 id="6-8-補充-Net-Logger-分級"><a href="#6-8-補充-Net-Logger-分級" class="headerlink" title="6/8 補充 .Net Logger 分級"></a>6/8 補充 .Net Logger 分級</h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Trace</td><td>0</td><td>包含最詳細訊息的記錄。 這些訊息可能包含敏感性應用程式資料。 這些訊息預設會停用，且永遠不應在生產環境中啟用。</td></tr><tr><td>Debug</td><td>1</td><td>開發期間用於互動式調查的記錄。 這些記錄主要應包含適用於偵錯的資訊，且不具備任何長期價值。</td></tr><tr><td>Information</td><td>2</td><td>追蹤應用程式一般流程的記錄。 這些記錄應具備長期值。</td></tr><tr><td>Warning</td><td>3</td><td>醒目提示應用程式流程中異常或未預期事件的記錄，這些異常或未預期事件不會造成應用程式執行停止。</td></tr><tr><td>Error</td><td>4</td><td>在目前執行流程因失敗而停止時進行醒目提示的記錄。 這些記錄應指出目前活動中的失敗，而非整個應用程式的失敗。</td></tr><tr><td>Critical</td><td>5</td><td>描述無法復原的應用程式或系統損毀，或需要立即注意重大失敗的記錄。</td></tr><tr><td>None</td><td>6</td><td>不會用來寫入記錄訊息。 指定記錄類別不應寫入任何訊息。</td></tr></tbody></table><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.marsen.me/2020/05/13/2020/dotnet_logger_with_elasticsearch_kibana/&quot;&gt;前篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上次使用 Nlog 直接與 ElasticSearch 作結合，&lt;
      
    
    </summary>
    
    
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[A社筆記] 閒聊 Product Backlog </title>
    <link href="https://blog.marsen.me/2020/05/28/2020/productbacklog/"/>
    <id>https://blog.marsen.me/2020/05/28/2020/productbacklog/</id>
    <published>2020-05-28T07:06:02.000Z</published>
    <updated>2020-09-01T12:49:24.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Although implementing only parts of Scrum is possible, the result is not Scrum.</p><blockquote></blockquote><p>雖然實施部分的 Scrum 是可能的，但結果並不是 Scrum 《Scrum Guide》</p></blockquote><p>之所以在文章一開頭就引述這段文字，是因為世界上太多 <code>Scrum But</code> 了;<br>而我下文所敘的則是 <code>Not Scrum</code>。<br>未來有機會再深入討論兩者的差異，對我來說主要是心態上的差異。</p><p>我們透明、檢核、調試，我們擁抱改變，我們有所堅持，我們有理想但我們也務實。<br>好啦，說不定只有你自已。  </p><p>在 A 社的導入的過程中，我開場白通常會說「這不是 Scurm」然後開始拿 Scurm 的東西說嘴。<br>至少對我來說，這比那些號稱「我們跑 Scrum」「But #^%!~…」要好得多，<br>與其讓你難以分辨斷句在哪，或是誤會怎麼 Scrum 這麼糞，不如讓我明確的告訴你「這不是 Scurm」。  </p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>蠻小巧的團隊，小到我覺得也許不用任何「敏捷」<br>分為兩個組成 QA 部門與 RD 部門，遠端工作的 RD 主管兼職 PM<br>QA 團隊的主管除了目前這個團隊，也要兼者作其它團隊的測試，<br>此外還有一個大主管，在國外有時差，每周固定會與成員們開 3 次的會。<br>RD 團隊成為會有一個 Daily Sync 的會議，每天約 5~10 分鐘。<br>整個團隊有使用 Azure DevOps 的看板，但是 QA 只會用來開 Bug。<br>但不知道什麼時候 Bug 才會被修復。</p><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><h3 id="Azure-DevOps-BackLogs-太像文件"><a href="#Azure-DevOps-BackLogs-太像文件" class="headerlink" title="Azure DevOps BackLogs 太像文件"></a>Azure DevOps BackLogs 太像文件</h3><p>Azure DevOps 的 BackLogs 放著許多 Feature ，<br>依據不同的功能，再將每個 Sprint 的 User Story 放進去<br>這些 Feature 永遠不會被作完，隨著時間過去，<br>儘管完成了許多 User Story ，但是也會有新的 User Story 被加進去。<br>而作為文件，他的巢狀結構又不足以面對複雜的需求內容，<br>分散式存儲對於維護與修改上也是相同不便。</p><h3 id="Bug-隨時蹦出"><a href="#Bug-隨時蹦出" class="headerlink" title="Bug 隨時蹦出"></a>Bug 隨時蹦出</h3><p>QA 的工作就是不斷的測試，一有發現問題就開立 Bug，<br>RD 有空就會去領來作，有時候也會有 RD 主管確認過後再分配給 RD<br>這導致不同面向的問題，RD 自領的情況可能會無序的作，<br>導致真正有價值的 Bug 無法第一時間被修正。<br>而如果每件事情都要 RD 主管確認後再進行動作，<br>RD 主管恐怕會變成瓶頸所在。</p><h2 id="BackLogs-簡介"><a href="#BackLogs-簡介" class="headerlink" title="BackLogs 簡介"></a>BackLogs 簡介</h2><p>下面是我在向團隊介紹 Backlogs 後的筆記。</p><p>在 Azure DevOps 上會有 BackLogs 與 Sprints &gt; Backlog。<br>恰巧與 Scurm 的 Product BackLogs 與 Sprints Backlog 可以一一對應。<br>如果以 XP 來說，可以投射到發佈計劃會議與迭代計劃會議中討論的「用戶故事清單」。<br>如果以 GTD 的方法論來說 BackLogs 可以當作收集一切事務的 Inbox，<br>而 Sprints &gt; Backlog 可以視作專案裡面的工作項目。</p><p>總的來說，這些方法論的名詞故有所不同，但本質上卻是非常接近的事務。<br>我們總是有許多新的想法，但是沒有足夠的時間作所有的事。<br>所以我們必須補捉這些想法，放入 BackLogs 之中<br>補捉了之後，必須排序，這裡的概念有「重要且緊急」先作 ( 參考 Eisenhower Matrix )，<br>或是「價值高」的先作，或是有影響力的先作 ( 參考 Impact Mapping )。<br>GTD 的概念是 5 分鐘能完成的想法，立刻去作不然就丟到 BackLogs ( Inbox ) 之中，<br>我認為團隊不適合這樣作，畢竟 GTD 是針對個人的工作法。<br>團隊反而要刻意不作為，才能讓真正重要的事情浮現，而不是被一堆雜訊 DDos，<br>所有想法我的建議是「丟到 Backlogs 之中」，然後定期梳理吧。</p><p>理論上大部份事情會由模糊到清晰，這是個過程，之後才會進入到一個可以被執行的階段。<br>在 Scurm 之中，常用「遠光燈」作例子，我個人比較喜歡用「通勤」舉例。</p><p>留個問題給你，誰來衡量 ? 團隊 ? PO ? 客戶 ?</p><p>想像一下你要上班了，在家裡你對公司的方向與位置其實有個大概的想法，<br>要走過哪些路口，經過某個大樓，穿越了一座橋後你需要待轉，<br>再過幾個紅綠燈，看到速食店後就可以開始找車位了。<br>實際上路後，也許路上施工，你必需繞個路，或是運氣很好一路綠燈。<br>哦，不!! 你的車拋錨了，你必須改搭公車，而它的路線是……  </p><p>有個大方向就是你的目標，路口、橋、大樓，就是你的每個迭代，<br>每次的煞車、轉彎或催油門就是再被細分下來的工作項目，<br>紅燈、拋錨、下雨天就是你真實上路後才會體驗到的事。<br>有個概念「Road Map」其實也是在說差不多的事。  </p><p>回到 Product BackLogs 與 Sprints Backlog ，<br>我們也就是不斷的細化這些項目，一直到可執行然後被執行為止。  </p><p>至於怎麼變快呢 ?<br>也許你要選一條最優路線，最短的距離最少的車流，沒有紅綠燈之類的，<br>也許你要有最棒的工具，最好的機車、定期保養之類的，<br>也許你要改變的開車習慣，不要危險駕駛、不任意切換車道等等…  </p><p>透過的調整工作順序、找尋最佳工具輔助與保持正確心態，是我目前的答案。  </p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Although implementing only parts of Scrum is possible, th
      
    
    </summary>
    
    
    
      <category term="Agile" scheme="https://blog.marsen.me/tags/Agile/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] Dotnet Logger 整合 Kibana Kibana 與 Elasticsearch</title>
    <link href="https://blog.marsen.me/2020/05/13/2020/dotnet_logger_with_elasticsearch_kibana/"/>
    <id>https://blog.marsen.me/2020/05/13/2020/dotnet_logger_with_elasticsearch_kibana/</id>
    <published>2020-05-13T07:47:03.000Z</published>
    <updated>2020-09-01T12:49:24.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>我將 ASP.Net Core 的 API 服務加上 Log。<br>Logger 使用 NLog ，載體我使用 Elasticsearch ，<br>使用者操作介面使用 Kibana。</p><p>然後面對開發者，我希望用 AOP 方式，<br>讓 Logger 與主邏輯分離。</p><ul><li>這裡會用到簡單基本的 docker 技術</li><li>透過 docker-compose 建立 Kibana 與 Elasticsearch</li><li>假設你已經會使用 Dotnet Core DI 注入 Logger</li><li>用最原生的方法實作 AOP</li><li>對你可能沒有幫助</li></ul><h2 id="Run-ElasticSearch-amp-Kibana-with-docker"><a href="#Run-ElasticSearch-amp-Kibana-with-docker" class="headerlink" title="Run ElasticSearch &amp; Kibana with docker"></a>Run ElasticSearch &amp; Kibana with docker</h2><p>在本機建立 ElasticSearch &amp; Kibana<br>首先建立 docker-compose.yaml 檔如下，<br>簡單說明一下內容:</p><ul><li>起一個 elasticsearch，port : 9200</li><li>起一個 kibana ，port : 5601，設定環境變數 <code>ELASTICSEARCH_URL</code> 為 <code>http://localhost:9200</code></li><li>網路名命為 elastic 使用 birdge 讓兩個 container 連起來</li><li><code>elasticsearch-data:</code> 實務上我想需要指定一個 storage(硬碟或 File System 之類的)</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">   <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.6.2</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elasticsearch-data:/usr/share/elasticsearch/data</span></span><br><span class="line">   <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xpack.monitoring.enabled=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xpack.watcher.enabled=false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">discovery.type=single-node</span></span><br><span class="line">   <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">   <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.6.2</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line">   <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">   <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTICSEARCH_URL=http://localhost:9200</span></span><br><span class="line">   <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">elasticsearch-data:</span></span><br></pre></td></tr></table></figure><p>執行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>完成後在本機瀏覽器瀏覽以下網址。<br>確定功能正常。</p><ul><li>Elasticsearch URL <a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a></li><li>Kibana URL <a href="http://localhost:5601/" target="_blank" rel="noopener">http://localhost:5601/</a></li></ul><h3 id="雷包"><a href="#雷包" class="headerlink" title="雷包"></a>雷包</h3><p>第一次啟動 Kibana 要 5 分鐘左右，但是我不確定是 docker 或是 Kibana 的問題</p><h2 id="Dotnet-Core-NLog-with-ElasticSearch"><a href="#Dotnet-Core-NLog-with-ElasticSearch" class="headerlink" title="Dotnet Core NLog with ElasticSearch"></a>Dotnet Core NLog with ElasticSearch</h2><p>首先必需安裝相關套件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Install-Package NLog.Web.AspNetCore</span><br><span class="line"></span><br><span class="line">Install-Package NLog</span><br><span class="line"></span><br><span class="line">Install-package NLog.Targets.ElasticSearch</span><br></pre></td></tr></table></figure><p><del>設定 <code>appsettings.json</code></del><br>(請見 <a href="#20200518-補充">20200518 的補充</a>)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ConnectionsString"</span>: &#123;</span><br><span class="line">    <span class="attr">"ElasticSearchServerAddress"</span>: <span class="string">"http://localhost:9200/"</span>  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定 nlog.config，注意以下路徑</p><ul><li><code>nlog &gt; extenstions &gt; assembly</code></li><li><code>nlog &gt; targets &gt; target</code></li><li><code>nlog &gt; rules &gt; logger</code></li></ul><p><del>這裡的重點是 <code>ElasticSearchServerAddress</code> 這組字串需設定成你的 ElasticSearchServerAddress</del><br>(請見 <a href="#20200518-補充">20200518 的補充</a>)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nlog</span> <span class="attr">xmlns</span>=<span class="string">"http://www.nlog-project.org/schemas/NLog.xsd"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autoReload</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">internalLogLevel</span>=<span class="string">"Info"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">internalLogFile</span>=<span class="string">"c:\temp\internal-nlog.txt"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- enable asp.net core layout renderers --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">assembly</span>=<span class="string">"NLog.Web.AspNetCore"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">assembly</span>=<span class="string">"NLog.Targets.ElasticSearch"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- the targets to write to --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- write logs to file  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">xsi:type</span>=<span class="string">"File"</span> <span class="attr">name</span>=<span class="string">"allfile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;currentdir&#125;\log\nlog-$&#123;shortdate&#125;.log"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"$&#123;longdate&#125;|$&#123;event-properties:item=EventId_Id&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ElasticSearch --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"ElasticSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xsi:type</span>=<span class="string">"ElasticSearch"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ConnectionStringName</span>=<span class="string">"ElasticSearchServerAddress"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">index</span>=<span class="string">"dotnetcore-nlog-elk-$&#123;date:format=yyyy.MM.dd&#125;"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">documentType</span>=<span class="string">"logevent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">includeAllProperties</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"[$&#123;date:format=yyyy-MM-dd HH\:mm\:ss&#125;][$&#123;level&#125;] $&#123;logger&#125; $&#123;message&#125; $&#123;exception:format=toString&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"MachineName"</span> <span class="attr">layout</span>=<span class="string">"$&#123;machinename&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"Time"</span> <span class="attr">layout</span>=<span class="string">"$&#123;longdate&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"level"</span> <span class="attr">layout</span>=<span class="string">"$&#123;level:uppercase=true&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"logger"</span> <span class="attr">layout</span>=<span class="string">" $&#123;logger&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">layout</span>=<span class="string">" $&#123;message&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"exception"</span> <span class="attr">layout</span>=<span class="string">" $&#123;exception:format=toString&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"processid"</span> <span class="attr">layout</span>=<span class="string">" $&#123;processid&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"threadname"</span> <span class="attr">layout</span>=<span class="string">" $&#123;threadname&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"stacktrace"</span> <span class="attr">layout</span>=<span class="string">" $&#123;stacktrace&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"Properties"</span> <span class="attr">layout</span>=<span class="string">"$&#123;machinename&#125; $&#123;longdate&#125; $&#123;level:uppercase=true&#125; $&#123;logger&#125; $&#123;message&#125; $&#123;exception&#125;|$&#123;processid&#125;|$&#123;stacktrace&#125;|$&#123;threadname&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- rules to map from logger name to target --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--All logs, including from Microsoft--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">minlevel</span>=<span class="string">"Trace"</span> <span class="attr">writeTo</span>=<span class="string">"allfile"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">minlevel</span>=<span class="string">"Trace"</span> <span class="attr">writeTo</span>=<span class="string">"ElasticSearch"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nlog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我的 Logger 代碼可能會類似這樣:<br>我想調整 Logger 代碼，不要與商務邏輯混在一起。</p><ul><li>一般的 Logger 我會用 AOP 的方式作成 Audit Log 記錄</li><li>catch Exception 的 Logger 我會統一處理</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ILogger logger;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">MyMethod</span>(<span class="params">Context ctx</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.LogInformation(<span class="string">"Hello Marsen"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span>/ do some thing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.LogError(<span class="string">"What's a Wonderful World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20200518-補充"><a href="#20200518-補充" class="headerlink" title="20200518 補充"></a>20200518 補充</h3><p><code>nlog.config</code> 與 <code>appsettings.json</code> 內容調整。</p><p>使用<a href="https://www.elastic.co/" target="_blank" rel="noopener">Elasticsearch Cloud</a>(以下簡稱 ESC)當作服務的儲存體。<br>踩到了一個雷包，當我把 <code>ElasticSearchServerAddress</code> 修改成 ESC 服務的 EndPoint<br>我發現 ESC 並未接收到 Log ，更奇怪的事情是，在我本機端 docker 所建置服務仍然收到了 Log。</p><p>查詢了一下最新的<a href="https://github.com/markmcdowell/NLog.Targets.ElasticSearch/wiki" target="_blank" rel="noopener">Nlog ElasticSearch Wiki</a>後，<br>應該改用 <code>uri</code> 屬性設定 EndPoint ，而沒有設定的情況下預設為 <code>localhost:9200</code> ，  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uri - Uri of a Elasticsearch node. Multiple can be passed comma separated.  </span><br><span class="line">Ignored if cloud id is provided. Layout Default: http:&#x2F;&#x2F;localhost:9200</span><br></pre></td></tr></table></figure><p>而要使用 ESC 的 EndPoint，除了設定 <code>uri</code> 外，還需要啟用授權。<br><code>requireAuth</code> 設定為 <code>true</code>(預設為<code>false</code>)，另外還要設定 <code>username</code> 與 <code>password</code>。<br><code>appsettings.json</code> 的 ConnectionsString 就可以刪除了。<br><code>nlog.config</code> 修改大致如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--略--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">xsi:type</span>=<span class="string">"ElasticSearch"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"elastic.co"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">index</span>=<span class="string">"dotnetcore-nlog-elk-$&#123;date:format=yyyy.MM.dd&#125;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">documentType</span>=<span class="string">"_doc"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">includeAllProperties</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">layout</span>=<span class="string">"[$&#123;date:format=yyyy-MM-dd HH\:mm\:ss&#125;][$&#123;level&#125;] $&#123;logger&#125; $&#123;message&#125; $&#123;exception:format=toString&#125;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">uri</span>=<span class="string">"https://**************elastic-cloud.com:9243"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">requireAuth</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">username</span>=<span class="string">"**********"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">password</span>=<span class="string">"******************"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--略--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Dotnet-Core-AOP"><a href="#Dotnet-Core-AOP" class="headerlink" title="Dotnet Core AOP"></a>Dotnet Core AOP</h2><p>用 AOP 的方式作成 Audit Log 記錄，<br>想法是方法的 in / out 我將想知道資訊記錄下來。<br>比如輸入的參數或是回傳值。<br>題外話，因為 AOP 的特性，如果方法處理到一半想要記錄是作不到的，<br>這是不是意味著必須重構將方法一分為二 ?  </p><p><a href="https://www.cnblogs.com/jlion/p/12394949.html" target="_blank" rel="noopener">參考這篇</a>，我會使用最基本的 Filter 實作 AOP，<br><img src="https://i.imgur.com/iZ391Rb.png" alt="Filter　簡介"><br>依據 <code>Filter</code> 的特性我在這裡會實作 <code>IActionFilter</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuditLogAttribute</span> : <span class="title">Attribute</span>, <span class="title">IActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuditLogAttribute</span>(<span class="params">ILogger&lt;AuditLogAttribute&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.LogInformation(<span class="string">"Result Filter End"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.LogInformation(<span class="string">"Result Filter Start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的最終目標是透過掛載 Attribute 的方式來讓 Logger 與解耦，<br>參考下方的程式碼。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ILogger logger;</span><br><span class="line"></span><br><span class="line">[<span class="meta">AuditLog</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">MyMethod</span>(<span class="params">Context ctx</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span>/ do some thing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.LogError(<span class="string">"What's a Wonderful World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡就有一件討厭的事，因為我的 Logger 都是透過建構子注入產生，<br>而自已本身也比較傾向不要使用公開 Property Injection 的方式*。<br>但是使用建構子在這裡會產生另一個問題，<br>我將無法使用掛載 Attribute 的方式處理 Logger<br>解決的方式是透過另一個 Attribute <code>ServiceFilterAttribute</code> 作間接掛載</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ILogger logger;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ServiceFilter(typeof(AuditLogAttribute))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">MyMethod</span>(<span class="params">Context ctx</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span>/ do some thing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.LogError(<span class="string">"What's a Wonderful World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣作還是有一些缺點，最明顯就是掛載的 Attribute 變長，<br>然後視覺上又是末端文字才能表達意涵，<br>另一點是原本約定成俗可以省略的<code>*Attribute</code>後綴不能省略了。</p><p>我想使用 <a href="http://www.castleproject.org/" target="_blank" rel="noopener">Castle</a> 與 <a href="https://autofac.org/" target="_blank" rel="noopener">AutoFac</a> 重作一次。<br>應該可以變得更加簡潔。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.humankode.com/asp-net-core/logging-with-elasticsearch-kibana-asp-net-core-and-docker" target="_blank" rel="noopener">https://www.humankode.com/asp-net-core/logging-with-elasticsearch-kibana-asp-net-core-and-docker</a></li><li><a href="https://kevintsengtw.blogspot.com/2018/07/aspnet-core-nlog-log-elasticsearch.html" target="_blank" rel="noopener">https://kevintsengtw.blogspot.com/2018/07/aspnet-core-nlog-log-elasticsearch.html</a></li><li><a href="https://kevintsengtw.blogspot.com/2018/07/aspnet-core-nlog-log-elasticsearch_9.html" target="_blank" rel="noopener">https://kevintsengtw.blogspot.com/2018/07/aspnet-core-nlog-log-elasticsearch_9.html</a></li><li><a href="https://www.cnblogs.com/jlion/p/12394949.html" target="_blank" rel="noopener">https://www.cnblogs.com/jlion/p/12394949.html</a></li><li><a href="https://paper.dropbox.com/doc/202001-DIAOP--Az2Kl_lUwdJulCygth_VSyrcAg-41nJ40hCmLj7o7haWhual" target="_blank" rel="noopener">https://paper.dropbox.com/doc/202001-DIAOP--Az2Kl_lUwdJulCygth_VSyrcAg-41nJ40hCmLj7o7haWhual</a></li><li><a href="https://blog.johnwu.cc/article/ironman-day14-asp-net-core-filters.html" target="_blank" rel="noopener">https://blog.johnwu.cc/article/ironman-day14-asp-net-core-filters.html</a></li><li><a href="https://edi.wang/post/2019/1/21/aspnet-core-dependency-injection-in-actionfilterattribute" target="_blank" rel="noopener">https://edi.wang/post/2019/1/21/aspnet-core-dependency-injection-in-actionfilterattribute</a></li><li>請比較 Property Injection 與其它的注入方式的優缺點。</li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;我將 ASP.Net Core 的 API 服務加上 Log。&lt;br&gt;Logger 使用 NLog ，載體我使用 Elast
      
    
    </summary>
    
    
    
      <category term="CI/CD" scheme="https://blog.marsen.me/tags/CI-CD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
      <category term="AOP" scheme="https://blog.marsen.me/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] Github 結合 Stryker 作變異測試</title>
    <link href="https://blog.marsen.me/2020/05/06/2020/github_action_with_stryker_mutator/"/>
    <id>https://blog.marsen.me/2020/05/06/2020/github_action_with_stryker_mutator/</id>
    <published>2020-05-06T01:03:30.000Z</published>
    <updated>2020-09-01T12:49:24.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>前年初次接觸<a href="https://blog.marsen.me/2018/03/20/2018/mutation_testing/">變異測試</a>，去年在看<a href="https://blog.marsen.me/2019/03/01/2019/book/refactoring/refactoring_Ch1/">重構</a>時偷換了概念，<br>將兩者結合了。</p><p>這次我想更進一步，將 CI Server 與之結合。</p><h2 id="Stryker-Net"><a href="#Stryker-Net" class="headerlink" title="Stryker.Net"></a>Stryker.Net</h2><p>跟據<a href="https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md" target="_blank" rel="noopener">Stryker Handbook</a>，<br>Stryker 主要有三個專案，</p><ul><li>Stryker (Javascript &amp; TypeScript)</li><li>Stryker4s (Scala)</li><li>Stryker.NET (.NET)</li></ul><p>我會使用我的練習用<a href="https://github.com/marsen/Marsen.NetCore.Dojo/" target="_blank" rel="noopener">專案</a>作為目標，<br>所以很理所當然的我會選擇 <code>Stryker.NET</code>，那我們就開始吧。</p><h2 id="開始"><a href="#開始" class="headerlink" title="開始"></a>開始</h2><h3 id="安裝-Stryker"><a href="#安裝-Stryker" class="headerlink" title="安裝 Stryker"></a>安裝 Stryker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool install -g dotnet-stryker</span><br></pre></td></tr></table></figure><h3 id="執行-Stryker"><a href="#執行-Stryker" class="headerlink" title="執行 Stryker"></a>執行 Stryker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet stryker -tp "['./test/Marsen.NetCore.Dojo.Tests/Marsen.NetCore.Dojo.Tests.csproj','./test/Marsen.NetCore.Dojo.Integration.Tests/Marsen.NetCore.Dojo.Integration.Tests.csproj']" -p="Marsen.NetCore.Dojo.csproj" -dk=$STRYKER_DASHBOARD_API_KEY</span><br></pre></td></tr></table></figure><p>注意幾個 cli 參數，<br><code>-tp</code> 明確指定測試的專案有哪些，可以用中括號<code>[]</code>傳入多個測試專案名稱，使用<code>,</code>作為分隔符<br><code>-p</code> 專案名稱<br><code>-dk</code> dashboard-api-key 這組 key 是用來與 <code>https://dashboard.stryker-mutator.io/</code> 互動的，<br>最主的功能是將報告上傳。<br>$STRYKER_DASHBOARD_API_KEY 是 <a href="https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets" target="_blank" rel="noopener">Github 的 Secrets</a></p><p>你可以執行 <code>dotnet stryker -h</code> 查看更多原始說明  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-tp|--test-projects Specify what test projects should run on the project under test.</span><br><span class="line">-p|--project-file &lt;projectFileName&gt; Used for matching the project references when finding the project to</span><br><span class="line">                                              mutate. Example: "ExampleProject.csproj"</span><br><span class="line">-dk|--dashboard-api-key &lt;api-key&gt; Api key for dashboard reporter. You can get your key here: https://dashboard.stryker-mutator.io</span><br></pre></td></tr></table></figure><h3 id="專案設定"><a href="#專案設定" class="headerlink" title="專案設定"></a>專案設定</h3><p>新增一個 <code>stryker-config.json</code><br>對我來說，最重要的是要記得設定 <code>stryker-config &gt; reporters &gt; dashboard</code> 這筆資料。<br><a href="https://github.com/stryker-mutator/stryker-net/blob/master/docs/Configuration.md" target="_blank" rel="noopener">詳細的說明的可以參考這篇</a>  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"stryker-config"</span>: &#123;</span><br><span class="line">    <span class="attr">"dashboard-project"</span>: <span class="string">"github.com/marsen/Marsen.NetCore.Dojo"</span>,</span><br><span class="line">    <span class="attr">"dashboard-version"</span>: <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"reporters"</span>: [</span><br><span class="line">      <span class="string">"json"</span>,</span><br><span class="line">      <span class="string">"dashboard"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-Github-上工作"><a href="#在-Github-上工作" class="headerlink" title="在 Github 上工作"></a>在 Github 上工作</h3><p>首先你必須在 <a href="https://dashboard.stryker-mutator.io/" target="_blank" rel="noopener">Dashboard</a>中 Enable Repository</p><p><img src="/images/2020/5/github_action_with_stryker_mutator_01.jpg" alt="Enable Repository">  </p><p>然後產生一組 Key</p><p><img src="/images/2020/5/github_action_with_stryker_mutator_02.jpg" alt="產生一組 Key"></p><p>接下來到 Github ， 我們將這組 Key 設定到 Secrets 之中</p><p><img src="/images/2020/5/github_action_with_stryker_mutator_03.jpg" alt="將 Key 設定至 Github"></p><p>再到 Github Actions 中，把 workflow 指令設定完成，</p><p><img src="/images/2020/5/github_action_with_stryker_mutator_04.jpg" alt="Github Actions"></p><p>觸發 CI 完成後，就可以在 <a href="https://dashboard.stryker-mutator.io/reports/github.com/marsen/Marsen.NetCore.Dojo/master" target="_blank" rel="noopener">Dashboard</a> 上看到報表啦。</p><p><img src="/images/2020/5/github_action_with_stryker_mutator_05.jpg" alt="結果呈現"></p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://blog.marsen.me/2019/03/01/2019/book/refactoring/refactoring_Ch1/">https://blog.marsen.me/2019/03/01/2019/book/refactoring/refactoring_Ch1/</a></li><li><a href="https://blog.marsen.me/2018/03/20/2018/mutation_testing/">https://blog.marsen.me/2018/03/20/2018/mutation_testing/</a></li><li><a href="https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md" target="_blank" rel="noopener">https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md</a></li><li><a href="https://github.com/stryker-mutator/stryker-net/blob/master/docs/Reporters.md#dashboard-reporter" target="_blank" rel="noopener">https://github.com/stryker-mutator/stryker-net/blob/master/docs/Reporters.md#dashboard-reporter</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;前年初次接觸&lt;a href=&quot;https://blog.marsen.me/2018/03/20/2018/mutation
      
    
    </summary>
    
    
    
      <category term="CI/CD" scheme="https://blog.marsen.me/tags/CI-CD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] Github 結合 SonarCloud 作代碼質量檢查 - 測試覆蓋率篇</title>
    <link href="https://blog.marsen.me/2020/04/30/2020/sonarqube_run_with_github_action_coverage/"/>
    <id>https://blog.marsen.me/2020/04/30/2020/sonarqube_run_with_github_action_coverage/</id>
    <published>2020-04-30T07:30:43.000Z</published>
    <updated>2020-09-01T12:49:24.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>承<a href="https://blog.marsen.me/2020/04/27/2020/sonarqube_run_with_github_action/">上篇</a>,<br>我已經將 SonarCloud 的代碼檢查與 Github Action 結合在一起了。<br>透過專案首頁的 Dashboard 與專案的 Budget 我可以知道目前專案的一些狀況，<br>壞味道、技術債等 …</p><h3 id="題外話，測試分類"><a href="#題外話，測試分類" class="headerlink" title="題外話，測試分類"></a>題外話，測試分類</h3><p>在我的專案中有兩種測試，單元測試與整合測試。<br>我的分類方法，單一類別的 public 方法就用單元測試包覆。<br>不同的類別之如果有組合的交互行為，就用整合測試包覆。</p><p>舉個簡單的例子，以購物流程來說，我有的類別如下 :  </p><ul><li>Cart(購物車)<ul><li>Add (加入商品)</li><li>Substract (移除商品)</li><li>CheckOut (結帳)</li></ul></li><li>Order (訂單)<ul><li>Caculate (計算結帳金額)</li></ul></li></ul><p>另外有兩種類別如下，</p><ul><li>ECoupon<ul><li>Caculate</li></ul></li><li>Promotion<ul><li>Caculate</li></ul></li></ul><p>上面的所有方法我都會加上單元測試作保護，<br>但是 Order 在呼叫 Caculate 的時候，<br>會以不同的順序組合 ECoupon.Caculate 與 Promotion.Caculate，<br>這個時候就有可能會產生不同的結果。</p><h2 id="執行測試"><a href="#執行測試" class="headerlink" title="執行測試"></a>執行測試</h2><p>同上一篇，整體的流程我們只要在 Build 完後加上測試即可。</p><ol><li>Begin</li><li>MSBuild</li><li><strong>Test</strong></li><li>End</li></ol><p>開發環境執行測試</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet test ./test/Marsen.NetCore.Dojo.Tests/Marsen.NetCore.Dojo.Tests.csproj</span><br></pre></td></tr></table></figure><p>產生測試報告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet test ./test/Marsen.NetCore.Dojo.Tests/Marsen.NetCore.Dojo.Tests.csproj --logger:trx;LogFileName=result.trx</span><br></pre></td></tr></table></figure><p>測試報告會產生一份 <code>result.trx</code> 檔，在測試專案目錄底下的 <code>TestResults</code> 資料夾裡。<br>如果要在 SonarCloud 上使用請設定 sonar.cs.vstest.reportsPaths (VSTest適用)，更多資訊請<a href="https://docs.sonarqube.org/latest/analysis/coverage/" target="_blank" rel="noopener">參考</a>。</p><p><img src="/images/2020/4/sonarqube_run_with_github_action_04.jpg" alt="result.trx">  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dotnet sonarscanner begin /k:"marsen_Marsen.NetCore.Dojo" /o:"marsen-github" /d:"sonar.host.url=https://sonarcloud.io" /d:"sonar.login="$SONAR_LOGIN</span><br><span class="line">dotnet build ".\Marsen.NetCore.Dojo.Integration.Test.sln"</span><br><span class="line">dotnet test ./test/Marsen.NetCore.Dojo.Tests/Marsen.NetCore.Dojo.Tests.csproj --logger:trx;LogFileName=result.trx</span><br><span class="line">dotnet sonarscanner end /d:"sonar.login="$SONAR_LOGIN</span><br></pre></td></tr></table></figure><h2 id="覆蓋率"><a href="#覆蓋率" class="headerlink" title="覆蓋率"></a>覆蓋率</h2><ol><li>Begin</li><li>MSBuild</li><li><strong>Test -產生報告</strong></li><li><strong>Test -覆蓋率</strong></li><li>End</li></ol><p>這裡實作上很簡單，但是在選擇上有一些困難與試誤，稍微作個記錄。</p><ol><li><p>dotconver (棄選)</p><ul><li>似乎要綁定 resharper 的 lincese</li><li>有 30 天的限制，不知道會不會影響功能</li><li>不知道怎麼用 commandline 下載執行程式至 Github Action 執行實體上。</li></ul></li><li><p>vstest.console.exe (棄選)</p><ul><li><del>似乎只能在 windows 上執行</del></li><li>可以透過參數開始功能 <code>--collect:&quot;Code Coverage&quot;</code>，但產生的 .cover 檔 SonarCloud 不支援需要轉換格式</li><li>不知道如何將 .cover 轉換為 .coverxml ， 可能是 visual studio enter prise 才有的功能 ?</li></ul></li><li><p>opencover (coverlet)</p><ul><li><del><code>/p:CoverletOutputFormat=opencover /p:CoverletOutput=./coverage/</code> 的語法不 Work</del></li><li><code>--collect:&quot;XPlat Code Coverage&quot;</code> 是比較新的參數用法，可以使用設定檔</li></ul></li></ol><p>因諸多原因，我最後選擇了 Opencover(Coverlet) 的作法，<br>記錄步驟如下，</p><p>首先要在測試專案上安裝 Nuget 套件 <code>coverlet.collector</code>。<br>然後執行以下語法產生覆蓋率報告。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet test ./test/Marsen.NetCore.Dojo.Tests/Marsen.NetCore.Dojo.Tests.csproj --settings coverage.xml</span><br></pre></td></tr></table></figure><p>coverage.xml 設定檔如下，這個檔案必須是 xml 檔，檔名並沒有限制 :<br>Configuration &gt; Format 請記得填寫 <code>opencover</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RunSettings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DataCollectionRunSettings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DataCollectors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DataCollector</span> <span class="attr">friendlyName</span>=<span class="string">"XPlat code coverage"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Format</span>&gt;</span>opencover<span class="tag">&lt;/<span class="name">Format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">DataCollector</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">DataCollectors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">DataCollectionRunSettings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RunSettings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最後至 <code>SonarCloud</code> 上設定 <code>sonar.cs.opencover.reportsPaths</code> 的路徑</p><p><img src="/images/2020/4/sonarqube_run_with_github_action_05.jpg" alt="result.trx">  </p><p>最後的最後，就來個 Budget 大集合吧</p><p><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=bugs" alt="Bugs"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=code_smells" alt="Code Smells"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=coverage" alt="Coverage"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=duplicated_lines_density" alt="Duplicated Lines (%)"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=ncloc" alt="Lines of Code"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=sqale_rating" alt="Maintainability Rating"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=alert_status" alt="Quality Gate Status"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=reliability_rating" alt="Reliability Rating"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=security_rating" alt="Security Rating"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=sqale_index" alt="Technical Debt"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/measure?project=marsen_Marsen.NetCore.Dojo&metric=vulnerabilities" alt="Vulnerabilities"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/images/project_badges/sonarcloud-black.svg" alt="SonarCloud"></a><br><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/quality_gate?project=marsen_Marsen.NetCore.Dojo" alt="Quality gate"></a></p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://docs.sonarqube.org/latest/analysis/coverage/" target="_blank" rel="noopener">Test Coverage &amp; Execution</a></li><li><a href="https://blog.johnwu.cc/article/docker-dotnet-coverage-report-generator.html" target="_blank" rel="noopener">Docker 教學 - .NET Core 測試報告 (Coverlet + ReportGenerator)</a></li><li><a href="https://discoverdot.net/projects/coverlet" target="_blank" rel="noopener">Coverlet</a></li><li><a href="https://medium.com/agilix/collecting-test-coverage-using-coverlet-and-sonarqube-for-a-net-core-project-ef4a507d4b28" target="_blank" rel="noopener">Collecting test coverage using Coverlet and SonarQube for a .net core project</a></li><li><a href="https://codeburst.io/code-coverage-in-net-core-projects-c3d6536fd7d7" target="_blank" rel="noopener">Code Coverage in .NET Core Projects</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;承&lt;a href=&quot;https://blog.marsen.me/2020/04/27/2020/sonarqube_run
      
    
    </summary>
    
    
    
      <category term="CI/CD" scheme="https://blog.marsen.me/tags/CI-CD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] Github 結合 SonarCloud 作代碼質量檢查</title>
    <link href="https://blog.marsen.me/2020/04/27/2020/sonarqube_run_with_github_action/"/>
    <id>https://blog.marsen.me/2020/04/27/2020/sonarqube_run_with_github_action/</id>
    <published>2020-04-27T09:01:46.000Z</published>
    <updated>2020-09-01T12:49:24.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>大概一年前我曾寫過一篇 Blog <a href="https://blog.marsen.me/2019/05/16/2019/opensource_with_sonarcloud/">[實作筆記] 讓 SonarQube 檢查你的代碼</a>，<br>沒什麼含金量，只是我個人用來記錄的筆記。<br>當初有一些問題沒有排除，加上工作一忙就沒有後續了。  </p><p>我的理想目標是，每當我上 Code 到線上 Repo 時(Github)，<br>SonarCloud 可以幫我檢查代碼，跑跑測試覆蓋率，刷新一下 Budget，<br>如果有異常(覆蓋率下降、壞味道等…)最好再發個通知給我。<br>這些功能要怎麼作到呢 ?</p><p>然後我會實際用在我的<a href="https://github.com/marsen/Marsen.NetCore.Dojo" target="_blank" rel="noopener">SideProject</a>上，<br>這個 Project 單純只是為了練習而生，<br>專注於我個人的測試項目，主要語言為 Csharp 也有一些 TypeScript 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先先排序一下優先序吧。</p><ol><li>一定要可以執行代碼檢查</li><li>要能結合 CI ，我以 Github Action 作為我的主要 CI 工具</li><li>能夠跑測試並輸出測試報告</li><li>Badge 刷新</li><li>發通知</li></ol><p>這篇主要會說明如何結合 CI 執行代碼檢查。<br>執行代碼檢查就發現有一個問題， SonarCloud 一次只能對一種語言作檢查，<br>雖然我的專案裡有兩種語言，但是以 C# 佔大宗(93%)，所以調整一下目標，<br>先優先完成 C# 的代碼檢查、結合 CI 與輸出測試報告。<br>之後再進行 Typescript 的檢查與測試，最後通知有的話很棒，沒有也沒關係啦 :)。  </p><h2 id="本機執行代碼檢查"><a href="#本機執行代碼檢查" class="headerlink" title="本機執行代碼檢查"></a>本機執行代碼檢查</h2><p>我本機的環境有兩個，一個是 Windows 一個 macOS，我這裡只討論 Windows 的作法，<br>然後我就要直上 CI 了，Github Action 我並不熟悉，但是我知道上面應該是執行 Linux like 的作業系統。  </p><p>首先要在 SonarCloud 上建立 Project ，<br>可以參考 <a href="https://sonarcloud.io/documentation/integrations/github/" target="_blank" rel="noopener">Get started with GitHub.com</a> 快速建立。  </p><p>Administrator &gt; Analysis Method  </p><p><img src="/images/2020/4/sonarqube_run_with_github_action_02.jpg" alt="Analysis Method">  </p><p>這裡要把 SonarCloud Automatic Analysis 的功能關掉。<br>SonarCloud 支援自動分析語言只有以下</p><p>ABAP, Apex, CSS, Flex, Go, HTML, JS, Kotlin, PHP, Python, Ruby, Scala, Swift, TypeScript, XML.  </p><p>雖然有很多，但可惜並沒有 C# ，所以要先關掉，不然 Github Action 執行時會收到下面的錯誤。</p><p><code>You are running CI analysis while Automatic Analysis is enabled. Please consider disabling one or the other.</code></p><p>另外目前支援的 CI 服務有 Circle CI 與 Travis CI ，<br>一樣殘念的是沒有支援 Github Action 。<br>另外兩個選項目是 Other CI 與 Manunally (手動) 。<br>我的前一篇文章就是使用手動的方式把檢查報告打到 SonarCloud。<br>雖然只隔一年，但 UI 介面上已經有些差距，我還是再作一次介紹。</p><p><img src="/images/2020/4/sonarqube_run_with_github_action_01.jpg" alt="Analysis Method"></p><p>首先先下載 SonarScanner，選擇正確的語言(Others)與OS(Windows)後下載，<br>接著設定環境變數  </p><p><img src="/images/2020/4/sonarqube_run_with_github_action_03.jpg" alt="Setting Path">  </p><p>最後開啟 CMD 切換到專案目錄底下後。<br>執行語法，如果照著上述步驟，你可以在 Download 的按鈕下方找到語法，同時它會幫你填好 Token。  </p><p>Begin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet sonarscanner begin /k:"$ProjectKey" /o:"$Oragnization" /d:"sonar.host.url=https://sonarcloud.io" /d:"sonar.login="$Sonar_Login</span><br></pre></td></tr></table></figure><p>MSBuild</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet build ".\Marsen.NetCore.Dojo.Integration.Test.sln"</span><br></pre></td></tr></table></figure><p>End</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet sonarscanner end /d:"sonar.login="$Sonar_Login</span><br></pre></td></tr></table></figure><p><code>$ProjectKey</code> 與 <code>$Oragnization</code> 這兩個變數可以在 SonarCloud 的 Overview 介面的右下角找到，<br><code>$Sonar_Login</code> 則可以透過 <a href="https://sonarcloud.io/account/security" target="_blank" rel="noopener">Security</a> 設定。</p><p>執行命名完成後，大概幾秒內就可以在 SonarCloud 中看到結果了。</p><p>簡單總結一下</p><ol><li>你要有 SonarCloud</li><li>要下載 SonarScanner</li><li>依序執行 Begin &gt; MSBuild &gt; End</li></ol><p>另外有一些雷包，在這裡也記錄一下</p><ul><li>要安裝 Java (Java8)</li><li>執行語法的目錄底下不能有<code>sonar-project.properties</code><ul><li>不然會報錯 (sonar-project.properties files are not understood by the SonarScanner for MSBuild.)</li><li>我覺得應該是我的檔案內容有誤，但是還不知道怎麼修正。總之直接移除對我來說是可以 work 的。  </li></ul></li></ul><h2 id="CI-執行代碼檢查"><a href="#CI-執行代碼檢查" class="headerlink" title="CI 執行代碼檢查"></a>CI 執行代碼檢查</h2><p>同上面的概念，只要讓你的 CI Server 在執行的過程中依序執行 Begin &gt; MSBuild &gt; End 即可，<br>參考 Github Action 的 yaml 檔</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上略</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dotnet</span> <span class="string">Sonarscanner</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">dotnet</span> <span class="string">tool</span> <span class="string">install</span> <span class="string">--global</span> <span class="string">dotnet-sonarscanner</span> <span class="string">--version</span> <span class="number">4.8</span><span class="number">.0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SonarScanner</span> <span class="string">Begin</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">dotnet</span> <span class="string">sonarscanner</span> <span class="string">begin</span> <span class="string">/k:"marsen_Marsen.NetCore.Dojo"</span> <span class="string">/o:"marsen-github"</span> <span class="string">/d:"sonar.host.url=https://sonarcloud.io"</span> <span class="string">/d:"sonar.login="$SONAR_LOGIN</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">dotnet</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">dotnet</span> <span class="string">build</span> <span class="string">".\Marsen.NetCore.Dojo.Integration.Test.sln"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SonarScanner</span> <span class="string">End</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">dotnet</span> <span class="string">sonarscanner</span> <span class="string">end</span> <span class="string">/d:"sonar.login="$SONAR_LOGIN</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">SONAR_LOGIN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SONAR_LOGIN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>這裡要注意的是，<br>首先每次你都需要安裝 Dotnet Sonarscanner ，<br>其實我不清楚 Github Action 背後的機制，但是我猜測應該是用到容器化的技術，<br>每次 CI 執行時都會起一個實體(這個可設定，<del>但是 Linux Like 的 OS 又快又便宜，就別考慮 Windows了吧</del>請<a href="https://help.github.com/en/actions/reference/virtual-environments-for-github-hosted-runners" target="_blank" rel="noopener">參考</a>)<br>所以每次都要重頭安裝相關的軟體，比如 : Dotnet Sonarscanner  。</p><p>另外一點是，環境變數的設定，可以看到最後面的 <code>env</code> 變數。<br>這個是機制是將 CI 的設定傳到實體的環境變數之中。<br>在 yaml 中綁定要使用 <code>$+變數名</code> EX: <code>SONAR_LOGIN</code><br>其它的變數，你可以在 Github 的 <a href="https://github.com/marsen/Marsen.NetCore.Dojo/settings/secrets" target="_blank" rel="noopener">Secrets</a> 頁面設定。<br>另外 Github 有些預設的<a href="https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables" target="_blank" rel="noopener">變數</a>。<br>更多資訊可以<a href="https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets#in-this-article" target="_blank" rel="noopener">參考</a></p><p>設定成功後，每次進 Code 就能看到代碼的壞味道、重複或是資安風險等資訊囉。<br>可以參觀一下<a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener">我的專案</a>。</p><p><a href="https://sonarcloud.io/dashboard?id=marsen_Marsen.NetCore.Dojo" target="_blank" rel="noopener"><img src="https://sonarcloud.io/api/project_badges/quality_gate?project=marsen_Marsen.NetCore.Dojo" alt="Quality gate"></a></p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://sonarcloud.io/documentation/integrations/github/" target="_blank" rel="noopener">Get started with GitHub.com</a></li><li><a href="https://github.com/marketplace/actions/sonarcloud-scan" target="_blank" rel="noopener">SonarCloud Scan</a></li></ul><h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><ul><li><a href="https://studyhost.blogspot.com/2020/07/azure-devops-in-action-build-pipeline_26.html?fbclid=IwAR2PXmn_O91Z_duGpn5_z-tKAzvtZGc147omxtCkZDNk0xGRSwKqKRofy3M" target="_blank" rel="noopener">Azure DevOps in Action - 在Build Pipeline當中加入自動化程式碼檢查</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;大概一年前我曾寫過一篇 Blog &lt;a href=&quot;https://blog.marsen.me/2019/05/16/20
      
    
    </summary>
    
    
    
      <category term="CI/CD" scheme="https://blog.marsen.me/tags/CI-CD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] 使用 IIS 作為 Reverse Proxy Server</title>
    <link href="https://blog.marsen.me/2020/04/24/2020/iis_reverse_proxy/"/>
    <id>https://blog.marsen.me/2020/04/24/2020/iis_reverse_proxy/</id>
    <published>2020-04-24T02:31:22.000Z</published>
    <updated>2020-04-29T17:41:11.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><ol><li>作業系統為 Windows 10</li><li>IIS 的版本為 10.0.18362.1</li><li>前端使用 nodejs 開發了一個網站，會在 localhost:3000 執行，提供 UI</li><li>使用 dotnet core 開發了一個網站，在 IIS 上執行，用來提供 Api</li><li>透過鎖 Host 的方式 dotnet core 的網站綁定在 <code>http://dev.api.test</code></li></ol><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li>即使只有開發階段，我也不想看到 localhost:3000 作為我的網址</li><li>我想看到 <code>http://dev.site.test</code> 作為我的站台</li></ol><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><p>首先，鎖 Host <code>127.0.0.1 dev.site.test</code>，<br>Host 的檔案路徑為 <code>C:\Windows\System32\drivers\etc</code>。</p><p>接下來請下載並安裝 <a href="https://www.iis.net/downloads/microsoft/url-rewrite" target="_blank" rel="noopener">URL Rewrite</a> 與 <a href="https://www.iis.net/downloads/microsoft/application-request-routing" target="_blank" rel="noopener">Application Request Routing</a>。</p><p>IIS 建立網站，繫結我設定為 <code>dev.site.test:80</code>，<br>應用程式集區我沒有特別處。<br>到 IIS 選取站台的 Url Rewrite 新增規則<br><img src="/images/2020/4/iis_reverse_proxy_01.jpg" alt="到 IIS 選取站台的 Url Rewrite 新增規則"><br>選取 Reverse Proxy 規則  </p><p><img src="/images/2020/4/iis_reverse_proxy_02.jpg" alt="選取 Reverse Proxy 規則">  </p><p>填寫 <code>localhost:3000</code></p><p><img src="/images/2020/4/iis_reverse_proxy_03.jpg" alt="填寫 `localhost:3000`">  </p><p>這個時候前往 dev.site.test 就可以看到站台囉。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.iis.net/downloads/microsoft/url-rewrite" target="_blank" rel="noopener">URL Rewrite</a></li><li><a href="https://www.iis.net/downloads/microsoft/application-request-routing" target="_blank" rel="noopener">Application Request Routing</a></li><li><a href="https://dev.to/petereysermans/hosting-a-node-js-application-on-windows-with-iis-as-reverse-proxy-397b" target="_blank" rel="noopener">Hosting a Node.js application on Windows with IIS as reverse proxy</a></li><li><a href="https://tecadmin.net/set-up-reverse-proxy-using-iis/" target="_blank" rel="noopener">How to Setup Reverse Proxy on IIS with URL-Rewrite</a></li><li><a href="https://blog.miniasp.com/post/2009/04/13/Using-ARR-to-implement-Reverse-Proxy" target="_blank" rel="noopener">如何利用 IIS7 的 ARR 模組實做 Reverse Proxy 機制</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;情境&quot;&gt;&lt;a href=&quot;#情境&quot; class=&quot;headerlink&quot; title=&quot;情境&quot;&gt;&lt;/a&gt;情境&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作業系統為 Windows 10&lt;/li&gt;
&lt;li&gt;IIS 的版本為 10.0.18362.1&lt;/li&gt;
&lt;li&gt;前端使用 no
      
    
    </summary>
    
    
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] 從 TDD 到 TDD ，Todo 到 Test 趨動開發(二)</title>
    <link href="https://blog.marsen.me/2020/04/04/2020/todo_driven_develop_to_test_driven_develop_2/"/>
    <id>https://blog.marsen.me/2020/04/04/2020/todo_driven_develop_to_test_driven_develop_2/</id>
    <published>2020-04-04T10:22:40.000Z</published>
    <updated>2020-04-29T17:41:11.556Z</updated>
    
    <content type="html"><![CDATA[<p>承<a href="https://blog.marsen.me/2020/02/26/2020/todo_driven_develop_to_test_driven_develop_1/">上篇</a></p><h2 id="異常處理的-Todo-項目"><a href="#異常處理的-Todo-項目" class="headerlink" title="異常處理的 Todo 項目"></a>異常處理的 Todo 項目</h2><p>異常處理有幾種狀況，<br>一種是回傳的狀態有異常，<br>一種是回傳的資料有異常，<br>最後一種是超乎預期的異常，<br>比如說 Http 通訊上本身有問題。</p><p>再進一步分析這三種狀況，<br>我會寫下以下幾種情境</p><ol><li>回傳的狀態有異常，記錄回傳的異常狀態，拋出 Exception</li><li>回傳的資料有異常，記錄回傳的異常資料，回傳空資料</li><li>超乎預期的異常，記錄異常資料, 拋出 Exception</li></ol><h2 id="測試案例-回傳的狀態有異常，記錄回傳的異常狀態，拋出-Exception"><a href="#測試案例-回傳的狀態有異常，記錄回傳的異常狀態，拋出-Exception" class="headerlink" title="測試案例 回傳的狀態有異常，記錄回傳的異常狀態，拋出 Exception"></a>測試案例 回傳的狀態有異常，記錄回傳的異常狀態，拋出 Exception</h2><p>新增測試案例<br>這裡複製之前的測試案例，<br>再透過 inline Method 還原 arrange 部份的代碼，<br>再修改成我們想要的測試案例。</p><p>這裡我們先驗証拋出 Exception</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case6_Query_Error_Result</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _configService.GetAppSetting(<span class="string">"pickup.service.url"</span>)</span><br><span class="line">        .Returns(UrlMockResultError);</span><br><span class="line">    _storeSettingService.GetValue(_testStoreId, <span class="string">"pickup.service"</span>, <span class="string">"loginId"</span>).Returns(<span class="string">"testId"</span>);</span><br><span class="line">    _storeSettingService.GetValue(_testStoreId, <span class="string">"pickup.service"</span>, <span class="string">"auth"</span>).Returns(<span class="string">"testAuth"</span>);</span><br><span class="line">    target = <span class="keyword">new</span> PickupService(_configService, _storeSettingService);</span><br><span class="line"></span><br><span class="line">    Action act = () =&gt; target.GetUpdateStatus(_testStoreId, _testWaybillNo);</span><br><span class="line">    act.Should().Throw&lt;Exception&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Production Code 就單純很多了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.result == <span class="string">"error"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步我要驗証記錄 Log 的行為<br>出錯的時候應該呼叫 LogError 的方法</p><p>原本想直接驗証 LogError 有沒有被呼叫</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case7_Query_Error_Result_Should_LogError</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetPickupServiceWith(UrlMockResultError);</span><br><span class="line">    target.GetUpdateStatus(_testStoreId, _testWaybillNo);</span><br><span class="line">    _logger.Received().LogError(Arg.Any&lt;<span class="keyword">string</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因為這裡會拋出 Exception ，<br>所以無法直接呼叫  GetUpdateStatus<br>要修改前一個測試</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case6_Query_Error_Result</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetPickupServiceWith(UrlMockResultError);</span><br><span class="line">    Action act = () =&gt; target.GetUpdateStatus(_testStoreId, _testWaybillNo);</span><br><span class="line">    act.Should().Throw&lt;Exception&gt;();</span><br><span class="line">    _logger.ReceivedWithAnyArgs().LogError(<span class="keyword">default</span>(<span class="keyword">string</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Produciton Code 很單純的加上 Logger 並調整建構子</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="function"><span class="keyword">public</span> <span class="title">PickupService</span>(<span class="params">IConfigService configService, IStoreSettingService storeSettingService</span>)</span></span><br><span class="line"><span class="function">+   <span class="keyword">public</span> <span class="title">PickupService</span>(<span class="params">IConfigService configService, IStoreSettingService storeSettingService, ILogger logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._configService = configService;</span><br><span class="line">        <span class="keyword">this</span>._storeSettingService = storeSettingService;</span><br><span class="line">+       <span class="keyword">this</span>._logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj.result == <span class="string">"error"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">+       <span class="keyword">this</span>._logger.LogError(obj.result);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="回傳的資料有異常，記錄回傳的異常資料，回傳空資料"><a href="#回傳的資料有異常，記錄回傳的異常資料，回傳空資料" class="headerlink" title="回傳的資料有異常，記錄回傳的異常資料，回傳空資料"></a>回傳的資料有異常，記錄回傳的異常資料，回傳空資料</h2><p>測試案例</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case7_Query_Error_Content</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     GetPickupServiceWith(UrlMockContentError);</span><br><span class="line">     <span class="keyword">var</span> actual = target.GetUpdateStatus(_testStoreId, _testWaybillNo);</span><br><span class="line">     actual.Should().BeEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>調整代碼以通過測試</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(c.ErrorCode))</span><br><span class="line">+    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c.Status)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment"><span class="doctag">///</span>/略…</span></span><br><span class="line">        &#125;</span><br><span class="line">+    &#125;</span><br></pre></td></tr></table></figure><h2 id="超乎預期的異常，記錄異常資料-拋出-Exception"><a href="#超乎預期的異常，記錄異常資料-拋出-Exception" class="headerlink" title="超乎預期的異常，記錄異常資料, 拋出 Exception"></a>超乎預期的異常，記錄異常資料, 拋出 Exception</h2><p>測試</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case8_Query_Exception</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetPickupServiceWith(UrlMockException);</span><br><span class="line">    Action act = () =&gt; target.GetUpdateStatus(_testStoreId, _testWaybillNo);</span><br><span class="line">    act.Should().Throw&lt;Exception&gt;();</span><br><span class="line">    _logger.ReceivedWithAnyArgs().LogError(<span class="keyword">default</span>(<span class="keyword">string</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Production Code 就直接整個用 try Catch 包起來再記 Log</p><h2 id="實務上的案例"><a href="#實務上的案例" class="headerlink" title="實務上的案例"></a>實務上的案例</h2><p>這裡補充一些實務上的情境，</p><ol><li>呼叫狀態查詢時，對方的 API 只允許同查詢 100 筆 WayBillNo</li><li>呼叫 API 後多了幾種文件外的狀態需要處理<ul><li>D → Finish</li><li>F → Finish</li><li>E → Abnormal</li></ul></li></ol><h2 id="單元測試現身"><a href="#單元測試現身" class="headerlink" title="單元測試現身"></a>單元測試現身</h2><p>現在我已經有一些整合測試作保護了，<br>但是想要修改或重構仍然很麻煩，<br>原因是我每次有新的情境就需要準備新的 Mock API(實務上我需要準備符合情境的 WayBillNo)，<br>透過 Todo 與整合測試，已經讓我們的代碼有了雛型。<br>在一切太晚之前，我們需撰寫單元測試。</p><h3 id="Do-TODO-建立單元測試"><a href="#Do-TODO-建立單元測試" class="headerlink" title="Do TODO 建立單元測試"></a>Do TODO 建立單元測試</h3><p>這裡小小提個 Visual Studio 2019 的小問題 ，<br>預設只會安裝 MSTest 的 Generator ，<br>這裡我要安裝 <a href="https://marketplace.visualstudio.com/items?itemName=YowkoTsai.xUnitnetTestGenerator" target="_blank" rel="noopener">XUnit 的 Generator</a> ，<br>安裝完成後再透過 Code Generator 產生第一個測試，紅燈。</p><p>當然這種 Generator 產生的 Code 不是實際要的測試案例<br>調整一下測試案例</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ILogger logger = Substitute.For&lt;ILogger&gt;();</span><br><span class="line">IStoreSettingService storeSettingService = Substitute.For&lt;IStoreSettingService&gt;();</span><br><span class="line">storeSettingService.GetValue(Arg.Any&lt;<span class="keyword">long</span>&gt;(), <span class="string">"pickup.service"</span>, <span class="string">"auth"</span>).Returns(<span class="string">"FakeAuth"</span>);</span><br><span class="line">IConfigService configService = Substitute.For&lt;IConfigService&gt;();</span><br><span class="line">configService.GetAppSetting(<span class="string">"pickup.service.url"</span>).Returns(<span class="string">"https://test.com/"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">new</span> PickupService(configService, storeSettingService, logger);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> actual = target.GetUpdateStatus(<span class="number">2</span>, <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123;<span class="string">"TestWayBillNo"</span>&#125;);</span><br><span class="line">actual.Should().BeEquivalentTo(<span class="keyword">new</span> List&lt;ShippingOrderUpdateEntity&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> ShippingOrderUpdateEntity</span><br><span class="line">    &#123;</span><br><span class="line">        AcceptTime = <span class="keyword">new</span> DateTime(<span class="number">2020</span>, <span class="number">03</span>, <span class="number">03</span>, <span class="number">17</span>, <span class="number">51</span>, <span class="number">20</span>),</span><br><span class="line">        OuterCode = <span class="string">"TestWayBillNo"</span>,</span><br><span class="line">        Status = StatusEnum.Finish</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Legacy-Code-相依-HttpClient"><a href="#Legacy-Code-相依-HttpClient" class="headerlink" title="Legacy Code 相依 HttpClient"></a>Legacy Code 相依 HttpClient</h3><p>大部份的功能我都可以透過 DI 的手段隔離，<br>但是之前的 Test Driven Develop 的方法並沒有將 HttpClient 轉換成可以隔離的物件。<br>另外一部份代碼是透過 Copy Paste 手法產生的代碼，所以也有可能會有 Legacy Code。<br>這裡我優先處理 HttpClient 。</p><p>首先我要重構一小段代碼，所幸之前的整合測試可以保護我這段重構</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+       <span class="keyword">internal</span> HttpClient HttpClient;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> DeliveryOrder = <span class="string">"DeliveryOrder"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;ShippingOrderUpdateEntity&gt;();</span><br><span class="line">-           <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">+           <span class="keyword">this</span>.HttpClient?? = <span class="keyword">new</span> HttpClient();</span><br></pre></td></tr></table></figure><p>在測試的保護下，我要逐步修改我的 HttpClient ，<br>好讓我的單元測能夠通過。<br>其實我目前的單元測試還未完成，所以可以先 Skip 掉，<br>等 HttpClient 隔離完成後再回頭完成單元測試。</p><h3 id="隔離-HttpClient"><a href="#隔離-HttpClient" class="headerlink" title="隔離 HttpClient"></a>隔離 HttpClient</h3><p>這裡我要回顧一下，之前在作 <a href="https://blog.marsen.me/2020/01/29/2020/tdd_pay_api/">Kata_Api_Pay</a> 的時候，<br>我在 Production Code 建立了 <code>IHttpClient</code> 的介面，<br>用於隔離 <code>HttpClient</code> 。<br>我可以延用 HttpClient 但是因為我未實作 <code>DefaultRequestHeaders</code> 欄位，<br>這會導致一些錯誤;<br>雖然我可以一併調整但是這樣我要同時面對兩份遺留代碼，<br>我認為這樣的風險太大，而且使用 <code>IHttpClient</code> 目前看起來出現一些問題。</p><ol><li>雖然抽出介面，但依賴在 <code>HttpClient</code> 之上，未來有功能不足或未實作 HttpClient 的功能就仍需要調整。</li><li>最初的目的其實是為了隔離，而隔離的目的是為了好測試，這些代碼卻放在 Production Code 上實在很奇怪。</li></ol><p>基於以上種種理由，我要重新作一次隔離。<br>要達到幾個目地。</p><ol><li>真正的與 <code>HttpClient</code> 解耦，未來再有用到 HttpClient 的任何方法/欄位皆不影響即有代碼。</li><li>將這類的工具放到正確專案 <code>TestingToolkit</code> 之下，不再影響 Production Code</li></ol><p>首先允許測試專案存取 Production Code 的 Internal 欄位</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+       [assembly: InternalsVisibleTo(<span class="string">"Marsen.NetCore.Dojo.Tests"</span>)]</span><br><span class="line">        <span class="keyword">namespace</span> <span class="title">Marsen.NetCore.Dojo.Kata_PickupService</span></span><br></pre></td></tr></table></figure><p>下一步，偽造 HttpClient 的回傳值，<br>我們可以透過 HttpClient 的建構子作到這件事。<br>參考這篇<a href="https://dev.to/n_develop/mocking-the-httpclient-in-net-core-with-nsubstitute-k4j" target="_blank" rel="noopener">文章</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">target.HttpClient =</span><br><span class="line">    <span class="keyword">new</span> HttpClient(</span><br><span class="line">    <span class="keyword">new</span> MockHttpMessageHandler(JsonSerializer.Serialize(</span><br><span class="line">    <span class="keyword">new</span> ResponseEntity</span><br><span class="line">    &#123;</span><br><span class="line">        Result = <span class="string">""</span>,</span><br><span class="line">        Content = <span class="keyword">new</span> List&lt;Content&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Content</span><br><span class="line">            &#123;</span><br><span class="line">                ErrorCode = <span class="keyword">string</span>.Empty,</span><br><span class="line">                Status = Status.DONE,</span><br><span class="line">                lastStatusDate = <span class="string">"2020-03-03"</span>,</span><br><span class="line">                lastStatusTime = <span class="string">"17:51:20"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">HttpStatusCode.OK));</span><br></pre></td></tr></table></figure><p>偽造 HttpClient 的回傳值後，我就可以把單元測試的部份完成，<br>案例蠻多的，但是大同小異也沒有什麼特別的技法，<br>就不多贅述。</p><p>稍微提一下，反而在寫 Unit Test 過程中，<br>發現了 Production Code 一些 Over Design 的代碼。</p><p>比如說，多餘的邏輯分支，在某些因果條件，跟本不可能被執行到的代碼。<br>我視作無用的代碼將他移除。</p><p>另外也有發現一些 Entity 在呼叫 API 的過程不會取用它的資料或欄位，<br>也許有得人會想要移除這些 Entity ，但我會傾向保留，<br>原因是這些 Entity 是在整合測試階段被趨動出來的，<br>雖然沒有用到而且會使代碼的覆蓋率下降，<br>但是我認為這些代碼很有可能再下一個階段就會被用到，<br>在不影響功能的情況我不會刻意移除。</p><p>整體而言，測試已 100% 覆蓋，<br>也記錄了如何從 Todo Driven 到 TDD 的想法與技巧。<br>最後整理一下代碼，<br>把 MockHttpMessageHandler 搬到 TestingToolkit。<br>最後回頭把 api Pay 對 HttpClient 的處理調整一下就大功告成啦。</p><h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><ul><li><a href="https://dev.to/n_develop/mocking-the-httpclient-in-net-core-with-nsubstitute-k4j" target="_blank" rel="noopener">https://dev.to/n_develop/mocking-the-httpclient-in-net-core-with-nsubstitute-k4j</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;承&lt;a href=&quot;https://blog.marsen.me/2020/02/26/2020/todo_driven_develop_to_test_driven_develop_1/&quot;&gt;上篇&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;異常處理的-Todo-項目&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="Unit Testing" scheme="https://blog.marsen.me/tags/Unit-Testing/"/>
    
      <category term="TDD" scheme="https://blog.marsen.me/tags/TDD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] Macbook SSH 設置與疑問 </title>
    <link href="https://blog.marsen.me/2020/03/10/2020/macbook_ssh_add_and_git_fork/"/>
    <id>https://blog.marsen.me/2020/03/10/2020/macbook_ssh_add_and_git_fork/</id>
    <published>2020-03-09T18:02:31.000Z</published>
    <updated>2020-09-02T16:29:14.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近轉換了一下跑道 ，<br>剛好又了一點時間就想說順便換一下 OS 學一點新東西，<br>就敗了一台 MacBook ， 這幾天就忙著整理開發環境 。<br>在 ssh 上卡住了點 ， 就作點記錄順便上來提問 。</p><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><p>我安裝了 <a href="https://git-fork.com/" target="_blank" rel="noopener">git-fork</a> 作為我的 Git GUI 工具。<br>裡面有一個很方便的功能可以快速的設定 ssh ，  </p><p><img src="/images/2020/3/030901_fork_setting_ssh.png" alt="fork">  </p><p>於是我很輕鬆娛快的設定了一組 ssh key 我命名為 <code>MacBook</code><br>也可以很正常的在 fork 裡面作一些 git 的操作 ，<br>比如說 fetch push pull 等。</p><p>不過人在江湖飄， 哪有不挨刀。　　<br>身為一個開發者與一個 Git 的愛用者，<br>有很多情境是會離開 GUI 工具操作 Git 的 。<br>但是很奇怪，只要離開了 fork 我的 Git 部份指令就會失效，<br>錯誤訊息如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey).  </span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.  </span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br></pre></td></tr></table></figure><p>很明顯是權限不足的原因。<br>但是我查找了 <code>~/.ssh</code> 資料夾 ，<br>我設定的 private key <code>MacBook</code> 確實存在。  </p><p>所以我透過一個指令來取得更多資訊</p><p><code>ssh -vT git@github.com</code></p><p>輸出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">marsen@MarsendeMacBook-Pro ~ % ssh -vT git@github.com</span><br><span class="line">OpenSSH_7.9p1， LibreSSL 2.7.3</span><br><span class="line">debug1: Reading configuration data &#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line">debug1: &#x2F;etc&#x2F;ssh&#x2F;ssh_config line 48: Applying options for *</span><br><span class="line">debug1: Connecting to github.com [192.30.253.112] port 22.</span><br><span class="line">debug1: Connection established.</span><br><span class="line">debug1: identity file &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_rsa type -1</span><br><span class="line">debug1: identity file &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_rsa-cert type -1</span><br><span class="line">中間省略...  </span><br><span class="line">debug1: Trying private key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_ecdsa</span><br><span class="line">debug1: Trying private key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_ed25519</span><br><span class="line">debug1: Trying private key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_xmss</span><br><span class="line">debug1: No more authentication methods to try.</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br></pre></td></tr></table></figure><p>幾個奇怪的地方<br>一個是 identity file 或是 Trying private key 的檔案我都找不到 ，<br>另一個奇怪的點是 <code>~/.ssh/MacBook</code> 這組我剛剛建立的 private key 明明存在 ，<br>我確找不到他顯示在 identity file 或是 Trying private key 的記錄之中<br>總而言之，最後的訊息仍然是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey).</span><br></pre></td></tr></table></figure><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>指令 <code>ssh-add -K MacBook</code> 執行後， 就可正常運作。<br>小小猜測一下 ， 應該是 fork 運作的環境與一般 terminal 的環境有所差異，<br>所以需要額外透過指令加上 private key 才能夠執行。</p><p>不過我仍有疑問， fork 的設定在什麼地方可以調整呢 ?<br>另一個問題是 log 裡面這些不存在 private key 是在哪裡設定的 ?<br>查找過 <code>/etc/ssh/ssh_config</code> 裡面並沒有相關的設定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug1: Will attempt key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">debug1: Will attempt key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_dsa</span><br><span class="line">debug1: Will attempt key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_ecdsa</span><br><span class="line">debug1: Will attempt key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_ed25519</span><br><span class="line">debug1: Will attempt key: &#x2F;Users&#x2F;marsen&#x2F;.ssh&#x2F;id_xmss</span><br></pre></td></tr></table></figure><p><del>希望有人能有答案或提供文件可以參考一下。<br>不求甚解繼續玩 Mac 去。</del></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>20200407 : 在安裝 git-fork 的時候 ， 它會另外安裝一個 git 實體 ，<br>所以與 global 環境的 git 不會是同一個 ， 導致在 git-fork 的行為不一致 。<br>另外之所以使用 ssh 作為連線手段 ， 是因為以前使用 SourceTree 作為 Git Gui Tool 時<br>常常會 Https 的密碼過期而需要重新輸入 ， 如果信任 git-fork 的開發者 ，<br>可以考慮使用 Https 連線 ， 看起來 git-fork 會記錄你的連線資訊 ，<br>而不會在每次操作 git 時詢問你密碼。</p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近轉換了一下跑道 ，&lt;br&gt;剛好又了一點時間就想說順便換一下 OS 學一點新東西，&lt;br&gt;就敗了一台 MacBook ， 
      
    
    </summary>
    
    
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] 從 TDD 到 TDD ，Todo 到 Test 趨動開發(一)</title>
    <link href="https://blog.marsen.me/2020/02/26/2020/todo_driven_develop_to_test_driven_develop_1/"/>
    <id>https://blog.marsen.me/2020/02/26/2020/todo_driven_develop_to_test_driven_develop_1/</id>
    <published>2020-02-26T02:40:14.000Z</published>
    <updated>2020-04-29T17:41:11.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上次作完金流後，這次換作物流，<br>在開發的過程中首次全程用 TDD 進行(?)，<br>因為某些因素，測試沒有進版控，所以稍微記錄一下心路歷程。<br>但是那個 T 是什麼? 就請各位看下去了…</p><h2 id="需求說明"><a href="#需求說明" class="headerlink" title="需求說明"></a>需求說明</h2><p>出貨流程為:</p><ol><li>訂單成立</li><li>透過物流服務配號</li><li>出貨</li><li>透過物流服務查詢物流狀態</li><li>狀態正確，通知消費者取貨</li><li>狀態不正確，通知商家，人工處理。</li></ol><p>這次 TDD 進行的部份為流程上的第 4 步，<br>往下看我怎麼做的  </p><p>整體流程如下</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>Step0 . 這次不是從無到有，而是在遺留代碼之中建立測試，<br>所以我會準備一些「<a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/2e4e5ecffe96043b2c442cf468d90fc4d95c9fa4" target="_blank" rel="noopener">遺留代碼</a>」來呈現我面臨的狀況。</p><p>Step1 . 這次 TDD 先不是 Test 而 TODO，<br>直接對 Production Code 寫下 Todo List，<br>這個 TODO 的過程其實就是一種分析，一種需求拆分。  </p><p>這裡我先簡單拆成兩步，</p><ol><li>打 API 問狀態</li><li>將問到的資料轉換成回傳資料</li></ol><p>Step 2 . <a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/aba8811b4b0a2c3888341997ad69183264f67ac8" target="_blank" rel="noopener">隨著過程把 TODO 拆的更細</a></p><ol><li>打 API 問狀態<ol><li>建立 HttpClient</li><li>建立 auth</li><li>準備 HttpContent 資料</li><li>指定 API URL</li><li>呼叫</li></ol></li></ol><p>以往這個時候，我就會進開發了，<br>這次我不打算刻意改變我的開發習慣，<br>但是我會多作一件事，寫測試。<br>這個測試會直接呼叫我即將開發的方法，<br>而我的方法會真的去打 API 存取 DB 讀 Config Files 諸如此類的事情。</p><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><h3 id="第一個測試，但是沒有-Assert"><a href="#第一個測試，但是沒有-Assert" class="headerlink" title="第一個測試，但是沒有 Assert"></a>第一個測試，但是沒有 Assert</h3><p>我目前對測試案例沒有任何的想法(這是個壞味道)，<br>但是我打算直接<a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/12936d65ce60aec90c385716fe3fe90dfb8abad0" target="_blank" rel="noopener">透過測試呼叫我的 Prodction Code</a>  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case1_Just_Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> PickupService();</span><br><span class="line">    <span class="keyword">long</span> storeId = <span class="number">0</span>;</span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; waybillNo = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    target.GetUpdateStatus(storeId, waybillNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因為沒有想法，所以沒有 <code>Assert</code><br>這不算是測試，頂多是<strong>一個小工具</strong>可以隨時呼叫我的 Prodcution Code 而已  </p><h3 id="Do-Todo-建立-HttpClient"><a href="#Do-Todo-建立-HttpClient" class="headerlink" title="Do Todo 建立 HttpClient"></a><a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/1c1102457355992c1e75fcf47846404d60310f3d" target="_blank" rel="noopener">Do Todo 建立 HttpClient</a></h3><p>這裡依造我以前的開發習慣，直接開幹，<br>把 HttpClient new 出來，刪除 Todo Comment<br>Commited 然後發 Pull Request</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-            <span class="comment"><span class="doctag">///</span>/ TODO 1.建立 HttpClient</span></span><br><span class="line">+            <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br></pre></td></tr></table></figure><h3 id="Do-Todo-建立-auth"><a href="#Do-Todo-建立-auth" class="headerlink" title="Do Todo 建立 auth"></a><a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/5f5b85ab3ff97170f5ce51fac71e01bac8779b9f" target="_blank" rel="noopener">Do Todo 建立 auth</a></h3><p>通常在串接第三方服務的過程中，<br>第三方會提供沙盒(SandBob)作開發人員測試使用<br>這裡我加了一點遮罩，但實務上如果是沙盒的 auth 資訊<br>我可能會直接 Commit 進去(壞味道)。</p><p>注意!! 這時候還是 Production Code 喔<br>我可以在測試加個 TODO ，<br>未來這段應該被 Mock 而不是 Hard Code 寫死。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-           <span class="comment"><span class="doctag">///</span>/ TODO 2.建立 auth</span></span><br><span class="line">+           <span class="comment"><span class="doctag">///</span>/ TODO login id 抽參數</span></span><br><span class="line">+           httpClient.DefaultRequestHeaders.Add(<span class="string">"login_id"</span>, <span class="string">"testId"</span>);</span><br><span class="line">+           <span class="comment"><span class="doctag">///</span>/ TODO authorization 抽參數</span></span><br><span class="line">+           httpClient.DefaultRequestHeaders.Add(<span class="string">"authorization"</span>, <span class="string">"testAuth"</span>);</span><br></pre></td></tr></table></figure><h3 id="Do-Todo-準備-HttpContent-資料"><a href="#Do-Todo-準備-HttpContent-資料" class="headerlink" title="Do Todo 準備 HttpContent 資料"></a><a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/cde2c5b36c5848e58feb499656ae4da81c7bd3fc" target="_blank" rel="noopener">Do Todo 準備 HttpContent 資料</a></h3><p>準備 HttpContent 有很多種方式，<br>這裡我選擇 StringContent 來實作。<br>所以要包含物件轉換成 Json String 的行為，<br>需要參考 JsonSerializer 。<br>如果是不太熟悉的開發人員可能會另開 TODO，<br>但是我這裡就一次性的作掉了 。  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-           <span class="comment"><span class="doctag">///</span>/ TODO 3.準備 HttpContent 資料</span></span><br><span class="line"></span><br><span class="line">+           <span class="keyword">var</span> requestContent = JsonSerializer.Serialize(<span class="keyword">new</span> &#123; Type = <span class="string">"DeliveryOrder"</span>, waybillNo &#125;);</span><br><span class="line">+           <span class="keyword">var</span> httpContent = <span class="keyword">new</span> StringContent(requestContent, Encoding.UTF8, <span class="string">"application/json"</span>);</span><br></pre></td></tr></table></figure><h3 id="Take-a-break"><a href="#Take-a-break" class="headerlink" title="Take a break"></a>Take a break</h3><p>稍微休息一下，這裡我的開發流程基本上沒有改變，<br>除了多寫一個(整合)測試，而且每次都會稍微跑一下測試，<br>這個測試其實沒有 Assert ，唯一的幫助只能驗証執行方法時沒有 Exception</p><h3 id="重構"><a href="#重構" class="headerlink" title="重構"></a>重構</h3><p>重構應該落在開發之中，我看到兩個小問題</p><ol><li>我會 inline 掉多餘的參數 requestContent</li><li>Type = “DeliveryOrder” 對我來說是個 magic variable ，我會加 TODO 預計未來抽成常數(壞味道，Why not now ?)</li></ol><h3 id="Do-TODO-4-指定-API-URL-amp-TODO-5-呼叫"><a href="#Do-TODO-4-指定-API-URL-amp-TODO-5-呼叫" class="headerlink" title="Do TODO 4.指定 API URL &amp; TODO 5.呼叫"></a><a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/fb3fb84442b074838785d3155c6d79969fd5ba30" target="_blank" rel="noopener">Do TODO 4.指定 API URL &amp; TODO 5.呼叫</a></h3><p>修改代碼如下，拿到第一個紅燈<br>因為我沒有指定 url</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>/ TODO 4.指定 API URL</span></span><br><span class="line"><span class="keyword">string</span> url=<span class="keyword">string</span>.Empty;</span><br><span class="line"><span class="keyword">var</span> responseMessage = httpClient.PostAsync(url, httpContent).Result;</span><br></pre></td></tr></table></figure><p>為了修正這個紅燈我會指定 url，<br>實務上我會使用沙盒的 url ，<br>這裡我先用 mock api 取代 ，<br>mock api 的服務為 <a href="https://www.mocky.io/" target="_blank" rel="noopener">mocky</a>，<br>類似的服務很多，也不是本篇的重點，就不贅述了。</p><p>這次一次處理掉兩個 TODO ，<br>表示當初我 TODO Task 切的過小，<br>下次可以切大一些。</p><p>不算壞味道，就當學個經驗。</p><h3 id="第一次-TODO-作完之後"><a href="#第一次-TODO-作完之後" class="headerlink" title="第一次 TODO 作完之後"></a>第一次 TODO 作完之後</h3><p>當初規劃的 TODO Task 都作完了，<br>但是其實工作並沒有完成。  </p><p>我會再作進一步的分析，<br>可以看到原本的 TODO 產生了更多的 TODO ，<br>另外打完 API 後的處理也是個問題。</p><p>這邊要用到 <a href="https://blog.marsen.me/2018/12/27/2018/csm/to_sum_up_scrum/">walking skeleton</a> 的概念，　　<br>簡單說就是，先打通再迭代。</p><p>前面產生的 TODO 項目並不是「最」重要的，<br>我應該先處理回傳的資料，讓整件事情串通。<br>開立 TODO 如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="comment"><span class="doctag">///</span>/ TODO Parse Response Entity</span></span><br><span class="line">+ <span class="comment"><span class="doctag">///</span>/ TODO Switch Status</span></span><br><span class="line">+ <span class="comment"><span class="doctag">///</span>/ TODO Return ShippingOrderUpdateEntity List</span></span><br></pre></td></tr></table></figure><p>可以得知，我最終會回傳一包 List，<br>這個時候我可以 Assert 了</p><h3 id="修改第一個測試案例"><a href="#修改第一個測試案例" class="headerlink" title="修改第一個測試案例"></a>修改第一個測試案例</h3><p>這個階段我開始撥雲見日，我要很明確的寫下第一個測試案例，<br>第一個案例我會直接作 Happy Case ，<br>也就是目前的呼叫的 API<br>只打一筆，回傳 Done 的資料。</p><p>這裡進一步作需求分析，<br>呼叫完 API 我會收到一大包 JSON 資料，<br>需要轉成我可以處理的物件，<br>其中最重要的欄位 lastStatusId 會回傳各種狀態，  </p><ul><li>DONE</li><li>FAIL</li><li>Arrived</li><li>Shipping</li><li>SMS</li><li>Expiry</li></ul><p>我只處理</p><ul><li>已取貨(DONE) 系統狀態為 Finish</li><li>失敗(FAIL、Expiry) 系統狀態為 Abnormal</li><li>貨到待取(Arrived) 系統狀態為 Arrived</li><li>出貨中(Shipping) 系統狀態為 Processing</li></ul><p>分析後，我的測項將會是向 API 循問一筆資料<br>且回傳一筆為 Done 的 ShippingOrderUpdateEntity 給我。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case1_Query_Done_waybillNo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> PickupService();</span><br><span class="line">    <span class="keyword">long</span> storeId = <span class="number">1</span>;</span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; waybillNo = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123;<span class="string">"TEST2002181800010"</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> actual = target.GetUpdateStatus(storeId, waybillNo).FirstOrDefault().Status;</span><br><span class="line">    actual.Should().Be(StatusEnum.Finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拿到紅燈-，Do-TODO-Parse-Response-Entity"><a href="#拿到紅燈-，Do-TODO-Parse-Response-Entity" class="headerlink" title="拿到紅燈 ，Do TODO Parse Response Entity"></a>拿到紅燈 ，<a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/38b41170115d3114953bfc91746ff3342c26dbc9" target="_blank" rel="noopener">Do TODO Parse Response Entity</a></h3><p>如果是 Test Driven 我可能會速解再加案例，<br>但是我現在是 Todo Driven 所以造著 Todo 作事，<br>透過 json2csharp 快速產生 Entity 來轉置 JSON 資料。</p><h3 id="如何從-T-odo-DD-到-T-est-DD"><a href="#如何從-T-odo-DD-到-T-est-DD" class="headerlink" title="如何從 T(odo)DD 到 T(est)DD"></a>如何從 T(odo)DD 到 T(est)DD</h3><p>寫到這裡我已經開始感覺 Todo 的挶限性了，<br>由於這個方法職責不分，所以要測試是困難的，<br>但是 Todo 的作法是無法趨動改變的。</p><p>現在開始，試著把每個 Todo Task 改變成 Test Case</p><h3 id="第二個測試案例開始之前"><a href="#第二個測試案例開始之前" class="headerlink" title="第二個測試案例開始之前"></a>第二個測試案例開始之前</h3><p>再次說明一下商務需求，我可以提供 waybillNo 向 API 循問物流的狀態。<br>理想上我會擁有一堆不同貨態的 waybillNo ，剛好可以作我測試的案例<br>但是在實務上，我拿不到這些案例， 我折衷的作法是透過 Dummy API 來偽裝回傳值。<br>這仍是整合測試的一種，雖然我可以 Mock API 的回傳值，<br>但在網路狀況異常下，測試仍會紅燈</p><p>在作 Dummy API 的前提下，要能抽換 URL<br>所以我會先作 TODO url 抽參數  </p><p>重構如下:</p><p>Production Code</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-        <span class="comment"><span class="doctag">///</span>/ TODO url 抽參數</span></span><br><span class="line">-        <span class="comment"><span class="doctag">///</span>/ string url= "http://www.mocky.io/v2/********";</span></span><br><span class="line">-        <span class="keyword">string</span> url = <span class="string">"http://www.mocky.io/v2/********"</span>;</span><br><span class="line">+        <span class="keyword">string</span> url = <span class="keyword">this</span>._configService.GetAppSetting(<span class="string">"pickup.service.url"</span>);</span><br></pre></td></tr></table></figure><p>Test Mock Return Value</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> configService = Substitute.For&lt;IConfigService&gt;();</span><br><span class="line">configService.GetAppSetting(<span class="string">"pickup.service.url"</span>)</span><br><span class="line">        .Returns(<span class="string">"http://www.mocky.io/v2/********"</span>);</span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">new</span> PickupService(configService);</span><br></pre></td></tr></table></figure><h3 id="進一步增新測試的可讀性"><a href="#進一步增新測試的可讀性" class="headerlink" title="進一步增新測試的可讀性"></a>進一步增新測試的可讀性</h3><p>可讀性真的是一個很抽象的觀念，之後有機會再深入探討<br>我的修改如下，主要的想法是「讓測試案例可以像對話般被閱讀」</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case1_Query_Done_waybillNo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = QueryWithDoneWaybillNo();</span><br><span class="line">    actual.Should().Be(StatusEnum.Finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二個測試案例-出貨中-Shipping"><a href="#第二個測試案例-出貨中-Shipping" class="headerlink" title="第二個測試案例 - 出貨中(Shipping)"></a><a href="https://github.com/marsen/Marsen.NetCore.Dojo/commit/611c73975702605a7420c991327ca1e4ed45ad46" target="_blank" rel="noopener">第二個測試案例 - 出貨中(Shipping)</a></h3><p>這裡就是用簡單的 Test Case 趨動 Production Code 的代碼生成</p><p>Test Code</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case2_Query_Shipping_waybillNo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = QueryWithShippingWaybillNo();</span><br><span class="line">    actual.Should().Be(StatusEnum.Processing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Production Code (部份)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-           <span class="comment"><span class="doctag">///</span>/ TODO Switch Status</span></span><br><span class="line">-           <span class="comment"><span class="doctag">///</span>/ TODO Return ShippingOrderUpdateEntity List</span></span><br><span class="line">-           result.Add(<span class="keyword">new</span> ShippingOrderUpdateEntity &#123;Status = StatusEnum.Finish&#125;);</span><br><span class="line">+           <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> obj.content)</span><br><span class="line">+           &#123;</span><br><span class="line">+               <span class="keyword">switch</span> (c.lastStatusId)</span><br><span class="line">+               &#123;</span><br><span class="line">+                   <span class="keyword">case</span> <span class="string">"DONE"</span>:</span><br><span class="line">+                       result.Add(<span class="keyword">new</span> ShippingOrderUpdateEntity &#123;Status = StatusEnum.Finish&#125;);</span><br><span class="line">+                       <span class="keyword">break</span>;</span><br><span class="line">+                   <span class="keyword">case</span> <span class="string">"Shipping"</span>:</span><br><span class="line">+                       result.Add(<span class="keyword">new</span> ShippingOrderUpdateEntity &#123;Status = StatusEnum.Processing&#125;);</span><br><span class="line">+                       <span class="keyword">break</span>;</span><br><span class="line">+               &#125;</span><br><span class="line">+           &#125;</span><br></pre></td></tr></table></figure><p>順手再重構了一下測試，<br>希望能提高可讀性</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Case2_Query_Shipping_waybillNo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = QueryWaybillNoWith(UrlMockShipping);</span><br><span class="line">    actual.Should().Be(StatusEnum.Processing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩下的測試案例"><a href="#剩下的測試案例" class="headerlink" title="剩下的測試案例"></a>剩下的測試案例</h3><ul><li>失敗(FAIL) 系統狀態為 Abnormal</li><li>失敗(Expiry) 系統狀態為 Abnormal</li><li>貨到待取(Arrived) 系統狀態為 Arrived</li></ul><h3 id="剩下的-TODO-項目"><a href="#剩下的-TODO-項目" class="headerlink" title="剩下的 TODO 項目"></a>剩下的 TODO 項目</h3><p>這個時候基本的功能都好了，來收拾一下剩下的 TODO 項目吧<br>主要都是取得設定值的功能，實務上這些設定值可能來自不同的服務<br>Database、Config Service 或 Settring API 等…<br>我在這裡先簡化成 <code>IStoreSettingService</code> 取值就好。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-           <span class="comment"><span class="doctag">///</span>/ TODO login id 抽參數</span></span><br><span class="line">-           httpClient.DefaultRequestHeaders.Add(<span class="string">"login_id"</span>, <span class="string">"testId"</span>);</span><br><span class="line"></span><br><span class="line">+           <span class="keyword">var</span> loginId = <span class="keyword">this</span>._storeSettingService.GetValue(storeId,<span class="string">"pickup.service"</span>,<span class="string">"loginId"</span>);</span><br><span class="line">+           httpClient.DefaultRequestHeaders.Add(<span class="string">"login_id"</span>, loginId);</span><br></pre></td></tr></table></figure><p>同時測試代碼也要修改，<br>注意這裡的 testId 其實是 Pickup Service 提供給我們的測試 Id<br>在 Production 你需要整合進你的 Database、Config Service 或 Settring API 裡<br>在整合測試可以直接 mock 它</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_storeSettingService.GetValue(_testStoreId, <span class="string">"pickup.service"</span>, <span class="string">"loginId"</span>).Returns(<span class="string">"testId"</span>);</span><br></pre></td></tr></table></figure><p>Auth 也是相同的處理</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-           <span class="comment"><span class="doctag">///</span>/ TODO authorization 抽參數</span></span><br><span class="line">-           httpClient.DefaultRequestHeaders.Add(<span class="string">"authorization"</span>, <span class="string">"testAuth"</span>);</span><br><span class="line">+           <span class="keyword">var</span> auth = <span class="keyword">this</span>._storeSettingService.GetValue(storeId,<span class="string">"pickup.service"</span>,<span class="string">"auth"</span>);</span><br><span class="line">+           httpClient.DefaultRequestHeaders.Add(<span class="string">"authorization"</span>, auth);</span><br></pre></td></tr></table></figure><p>Testing Mock</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_storeSettingService.GetValue(_testStoreId, <span class="string">"pickup.service"</span>, <span class="string">"auth"</span>).Returns(<span class="string">"testAuth"</span>);</span><br></pre></td></tr></table></figure><h2 id="心得小結"><a href="#心得小結" class="headerlink" title="心得小結"></a>心得小結</h2><p>TDD 不一定要用單元測試,<br>你可以試著從 T(Todo) Driven Development 到 T(Test) Driven Development<br>思考一下你目前的開發方式，<br>不要急著 TDD ，想像一下你開發到什麼程度會想要驗証(測試)，<br>試著在這個時間點加上測試就好，<br>這樣的開發方式，會比較貼近你的開發方式，<br>同時也可以練習寫測試，你會發現很多問題。<br>比如說:  </p><ul><li>你跟本沒有足夠了解需求，導致你寫不出驗收條件。</li><li>你根本不熟悉測試框架或是相關的 Library。</li><li>甚至你跟本不熟悉你賴以為生的開發工具與程式語言。</li><li>或是你跟本不會 Debug 跟 Google 而且以前你一直以為你會。</li><li>你把代碼搞得一蹋糊塗，而且沒有人愛你</li></ul><p>下一次試著先寫測試吧，改變一下自已的工作方式。<br>平順把你的開發方式轉換成 TDD 吧 。</p><p>下一篇我會透過整合測試，發現一些異常狀況，<br>並試著加上測試案例，並試著趨動。</p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;上次作完金流後，這次換作物流，&lt;br&gt;在開發的過程中首次全程用 TDD 進行(?)，&lt;br&gt;因為某些因素，測試沒有進版控，所
      
    
    </summary>
    
    
    
      <category term="Unit Testing" scheme="https://blog.marsen.me/tags/Unit-Testing/"/>
    
      <category term="TDD" scheme="https://blog.marsen.me/tags/TDD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[實作筆記] 用 TDD 寫一個 API Pay </title>
    <link href="https://blog.marsen.me/2020/01/29/2020/tdd_pay_api/"/>
    <id>https://blog.marsen.me/2020/01/29/2020/tdd_pay_api/</id>
    <published>2020-01-29T04:46:14.000Z</published>
    <updated>2020-04-29T17:41:11.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求說明"><a href="#需求說明" class="headerlink" title="需求說明"></a>需求說明</h2><p>金流系統透過打 API 與第三方介接來進行付款，<br>為了追蹤金流，在打 API 的過程中，業務單位要求要帶著 RequestId 。<br>再進行付款。<br>而 RequestId 由另一個專門負責提供 RequestId 的 API 來提供。</p><p>整體流程如下:</p><ol><li><p>打 API 取得 RequestId</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#123;&#123;url&#125;&#125;/api/&#123;&#123;version&#125;&#125;/requestId</span><br></pre></td></tr></table></figure></li><li><p>組合付款資料與 RequestId</p></li><li><p>打 API 完成付款</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST &#123;&#123;url&#125;&#125;/api/&#123;&#123;version&#125;&#125;/pay/CreditCard/&#123;&#123;transationId&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="第一個-Case，Pay-的時候應該呼叫-GET-reguestId-1次"><a href="#第一個-Case，Pay-的時候應該呼叫-GET-reguestId-1次" class="headerlink" title="第一個 Case，Pay 的時候應該呼叫 GET reguestId 1次"></a>第一個 Case，Pay 的時候應該呼叫 GET reguestId 1次</h2><p>問題，我需要驗証 HttpClient 呼叫的 <code>url</code>與<code>次數</code>。</p><p>一開始會寫成這樣，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay_should_Get_requestId</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> PaymentService();</span><br><span class="line">    target.Pay();</span><br><span class="line">    httpClient.Received().GetAsync(<span class="string">"https://testing.url/api/v1/requestId"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本來就預計使用 HttpClient 來呼叫 API,<br>但是直接使用 HttpClient 會直接產生耦合，<br>所以我建立一個介面來包裝它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpClient</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著馬上建立類別 <code>HttpClientProxy</code> 實作 <code>IHttpClient</code>,<br>這個時候我會知道我會使用 GetAsync 的方法，<br>所以我會讓 <code>IHttpClient</code> 長出這個同名方法，<br>實作很單純，就是呼叫  HttpClient().GetAsync 方法。</p><blockquote><p>幾個想法，<br>這樣算是 Proxy Pattern 嗎 ? 我覺得算是:P<br>另一點，這個階段我會擔心 HttpClient 的問題,<br>不處理是對的嗎 ?<br>如果不刻意處理的話 HttpClientProxy 好像會長不出來  </p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHttpClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;HttpResponseMessage&gt; <span class="title">GetAsync</span>(<span class="params"><span class="keyword">string</span> requestUri</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpClientProxy</span> : <span class="title">IHttpClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;HttpResponseMessage&gt; <span class="title">GetAsync</span>(<span class="params"><span class="keyword">string</span> requestUri</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpClient().GetAsync(requestUri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成這階段的修改後，我才可以透過 Framework 來 Mock IHttpClient，<br>寫好的測試如下，順利拿到第一個紅燈:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay_should_Get_requestId</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IHttpClient httpClient = Substitute.For&lt;IHttpClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> PaymentService(httpClient);</span><br><span class="line">    target.Pay();</span><br><span class="line">    httpClient.Received().GetAsync(<span class="string">"https://testing.url/api/v1/requestId"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>馬上修改 Production Code ，拿到綠燈。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PaymentService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IHttpClient _httpClient;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PaymentService</span>(<span class="params">IHttpClient httpClient</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _httpClient = httpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _httpClient.GetAsync(<span class="string">"https://testing.url/api/v1/requestId"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二個-Case，Pay-的時候應該呼叫-POST-Pay-CreditCard-1-次"><a href="#第二個-Case，Pay-的時候應該呼叫-POST-Pay-CreditCard-1-次" class="headerlink" title="第二個 Case，Pay 的時候應該呼叫 POST Pay CreditCard 1 次"></a>第二個 Case，Pay 的時候應該呼叫 POST Pay CreditCard 1 次</h2><p>測試案例:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay_should_Post_Pay_CreditCard</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IHttpClient httpClient = Substitute.For&lt;IHttpClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> PaymentService(httpClient);</span><br><span class="line">    target.Pay();</span><br><span class="line">    <span class="keyword">this</span>._httpClient.Received().PostAsync(<span class="string">"https://testing.url/api/v1/pay/CreditCard"</span>, Arg.Any&lt;HttpContent&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Production Code</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> readAsStringAsync = <span class="keyword">this</span>._httpClient.GetAsync(<span class="string">"https://testing.url/api/v1/requestId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._httpClient.PostAsync(<span class="string">"https://testing.url/api/v1/pay/CreditCard"</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重構測試</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay_should_Get_requestId</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WhenPay();</span><br><span class="line">    ShouldGetRequestId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay_should_Post_Pay_CreditCard</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WhenPay();</span><br><span class="line">    ShouldPayByCreditCard();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WhenPay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> PaymentService(_httpClient);</span><br><span class="line">    target.Pay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShouldGetRequestId</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._httpClient.Received(<span class="number">1</span>).GetAsync(<span class="string">$"<span class="subst">&#123;_testingApiUrl&#125;</span>requestId"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShouldPayByCreditCard</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._httpClient.Received(<span class="number">1</span>).PostAsync(<span class="string">$"<span class="subst">&#123;_testingApiUrl&#125;</span>pay/CreditCard"</span>,</span><br><span class="line">        Arg.Any&lt;HttpContent&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三個-Case，Pay-的時候應該先呼叫-Get-RequestId-再-POST-Pay-CreditCard"><a href="#第三個-Case，Pay-的時候應該先呼叫-Get-RequestId-再-POST-Pay-CreditCard" class="headerlink" title="第三個 Case，Pay 的時候應該先呼叫 Get RequestId 再 POST Pay CreditCard"></a>第三個 Case，Pay 的時候應該先呼叫 Get RequestId 再 POST Pay CreditCard</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay_should_Get_RequestId_Before_Post_Pay_CreditCard</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WhenPay();</span><br><span class="line">    Received.InOrder(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        ShouldGetRequestId();</span><br><span class="line">        ShouldPayByCreditCard();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>想法，有了第三個案例，我還需要前面兩個案例嗎 ?</p></blockquote><p>下一步，調整 ShouldPayByCreditCard 的 Assert 邏輯，<br>原因是實務上我必須將 RequestId 帶入 Post Pay 時的 HttpContent 裡面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShouldPayByCreditCard</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._httpClient.Received(<span class="number">1</span>).PostAsync(<span class="string">$"<span class="subst">&#123;_testingApiUrl&#125;</span>pay/CreditCard"</span>,</span><br><span class="line">    Arg.Is&lt;HttpContent&gt;(x =&gt; x.ReadAsStringAsync().Result.Contains(_testRequestId)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Prodouction Code 因而長出 <code>PayEntity</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> requestId = <span class="keyword">this</span>._httpClient.GetAsync(<span class="string">"https://testing.url/api/v1/requestId"</span>).Result.Content</span><br><span class="line">        .ReadAsStringAsync().Result;</span><br><span class="line">    HttpContent content = <span class="keyword">new</span> StringContent(</span><br><span class="line">    JsonSerializer.Serialize(</span><br><span class="line">        <span class="keyword">new</span> PayEntity</span><br><span class="line">        &#123;</span><br><span class="line">            RequestId = requestId</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._httpClient.PostAsync(<span class="string">"https://testing.url/api/v1/pay/CreditCard"</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PayEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> RequestId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Case4-組合資料邏輯"><a href="#Case4-組合資料邏輯" class="headerlink" title="Case4 組合資料邏輯"></a>Case4 組合資料邏輯</h2><h3 id="4-1-組合-PayEntity-的邏輯"><a href="#4-1-組合-PayEntity-的邏輯" class="headerlink" title="4.1 組合 PayEntity 的邏輯"></a>4.1 組合 PayEntity 的邏輯</h3><p>這次我假設外部的元件已組合好 <code>PayEntity</code> 傳入 PaymentService.Pay 方法，<br>唯一的組合邏輯就只剩 RequestId。<br>至於外部的 PayEntity 組合邏輯如何用 TDD 長出 Production Code 可以參考<a href="https://blog.marsen.me/2020/01/17/2020/tdd_with_parse_json/">這篇</a>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WhenPay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> PaymentService(_httpClient);</span><br><span class="line">    target.Pay(<span class="keyword">new</span> PayEntity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params">PayEntity payEntity</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">var</span> requestId = <span class="keyword">this</span>._httpClient.GetAsync(<span class="string">"https://testing.url/api/v1/requestId"</span>).Result.Content</span><br><span class="line">         .ReadAsStringAsync().Result;</span><br><span class="line">     HttpContent content = <span class="keyword">new</span> StringContent(</span><br><span class="line">         JsonSerializer.Serialize(</span><br><span class="line">             payEntity.RequestId = requestId));</span><br><span class="line">      <span class="keyword">this</span>._httpClient.PostAsync(<span class="string">"https://testing.url/api/v1/pay/CreditCard"</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後,將 api 的 url 也抽成可參數化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PaymentServiceTests</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._httpClient = Substitute.For&lt;IHttpClient&gt;();</span><br><span class="line">    <span class="keyword">this</span>._httpClient.GetAsync(Arg.Any&lt;<span class="keyword">string</span>&gt;()).ReturnsForAnyArgs(</span><br><span class="line">        Task.FromResult(</span><br><span class="line">            <span class="keyword">new</span> HttpResponseMessage</span><br><span class="line">            &#123;</span><br><span class="line">                Content = <span class="keyword">new</span> StringContent(_testRequestId)</span><br><span class="line">            &#125;));</span><br><span class="line">    <span class="keyword">this</span>._configure = Substitute.For&lt;IConfigure&gt;();</span><br><span class="line">    <span class="keyword">this</span>._configure.Setting(<span class="string">"PayService.Url"</span>).Returns(_testingApiUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Production Code</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PaymentService</span>(<span class="params">IHttpClient httpClient, IConfigure configure</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._httpClient = httpClient;</span><br><span class="line">    <span class="keyword">this</span>._configure = configure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params">PayEntity payEntity</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> apiUrl = <span class="keyword">this</span>._configure.Setting(<span class="string">"PayService.Url"</span>);</span><br><span class="line">    <span class="keyword">var</span> requestId = <span class="keyword">this</span>._httpClient.GetAsync(<span class="string">$"<span class="subst">&#123;apiUrl&#125;</span>requestId"</span>).Result.Content</span><br><span class="line">        .ReadAsStringAsync().Result;</span><br><span class="line">    HttpContent content = <span class="keyword">new</span> StringContent(</span><br><span class="line">        JsonSerializer.Serialize(</span><br><span class="line">        payEntity.RequestId = requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._httpClient.PostAsync(<span class="string">$"<span class="subst">&#123;apiUrl&#125;</span>pay/CreditCard"</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在 HttpClient 那邊卡蠻久的，用介面的方法包裝起來也不知道是否合適。<br>網路上有提供許多不同的作法，單元測試的 TDD 好像趨動不太出來 Production Code<br>是否需要加入整合測試，甚至是透過呼叫 Production Code 去打 API 作端到端測試，來趨動開發 ?<br>TDD 的 T 是不是不只是 Unit Test 呢 ?</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://chrissainty.com/unit-testing-with-httpclient/" target="_blank" rel="noopener">https://chrissainty.com/unit-testing-with-httpclient/</a></li><li><a href="https://dotblogs.com.tw/jakeuj/2019/01/25/httpclient" target="_blank" rel="noopener">https://dotblogs.com.tw/jakeuj/2019/01/25/httpclient</a></li><li><a href="https://blog.darkthread.net/blog/httpclient-sigleton/" target="_blank" rel="noopener">https://blog.darkthread.net/blog/httpclient-sigleton/</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求說明&quot;&gt;&lt;a href=&quot;#需求說明&quot; class=&quot;headerlink&quot; title=&quot;需求說明&quot;&gt;&lt;/a&gt;需求說明&lt;/h2&gt;&lt;p&gt;金流系統透過打 API 與第三方介接來進行付款，&lt;br&gt;為了追蹤金流，在打 API 的過程中，業務單位要求要帶著 Reque
      
    
    </summary>
    
    
    
      <category term="Unit Testing" scheme="https://blog.marsen.me/tags/Unit-Testing/"/>
    
      <category term="TDD" scheme="https://blog.marsen.me/tags/TDD/"/>
    
      <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
</feed>
